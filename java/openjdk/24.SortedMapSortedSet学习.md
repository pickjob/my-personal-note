# SortedMap & SortedSet 学习
- SortedMap SortedSet
    ```java
    public interface SortedMap<K,V> extends Map<K,V> {
        Comparator<? super K> comparator();
        SortedMap<K,V> subMap(K fromKey, K toKey);
        SortedMap<K,V> headMap(K toKey);
        SortedMap<K,V> tailMap(K fromKey);
        K firstKey();
        K lastKey();
        Set<K> keySet();
        Collection<V> values();
        Set<Map.Entry<K, V>> entrySet();
    }
    public interface SortedSet<E> extends Set<E> {
        Comparator<? super E> comparator();
        SortedSet<E> subSet(E fromElement, E toElement);
        SortedSet<E> headSet(E toElement);
        SortedSet<E> tailSet(E fromElement);
        E first();
        E last();
        @Override
        default Spliterator<E> spliterator() {
            return new Spliterators.IteratorSpliterator<E>(
                    this, Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED) {
                @Override
                public Comparator<? super E> getComparator() {
                    return SortedSet.this.comparator();
                }
            };
        }
    }
    ```
- NavigableMap NavigableSet
    ```java
    public interface NavigableMap<K,V> extends SortedMap<K,V> {
        Map.Entry<K,V> lowerEntry(K key);
        K lowerKey(K key);
        Map.Entry<K,V> floorEntry(K key);
        K floorKey(K key);
        Map.Entry<K,V> ceilingEntry(K key);
        K ceilingKey(K key);
        Map.Entry<K,V> higherEntry(K key);
        K higherKey(K key);
        Map.Entry<K,V> firstEntry();
        Map.Entry<K,V> lastEntry();
        Map.Entry<K,V> pollFirstEntry();
        Map.Entry<K,V> pollLastEntry();
        NavigableMap<K,V> descendingMap();
        NavigableSet<K> navigableKeySet();
        NavigableSet<K> descendingKeySet();
        NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,
                                K toKey,   boolean toInclusive);
        NavigableMap<K,V> headMap(K toKey, boolean inclusive);
        NavigableMap<K,V> tailMap(K fromKey, boolean inclusive);
        SortedMap<K,V> subMap(K fromKey, K toKey);
        SortedMap<K,V> headMap(K toKey);
        SortedMap<K,V> tailMap(K fromKey);
    }
    public interface NavigableSet<E> extends SortedSet<E> {
        E lower(E e);
        E floor(E e);
        E ceiling(E e);
        E higher(E e);
        E pollFirst();
        E pollLast();
        Iterator<E> iterator();
        NavigableSet<E> descendingSet();
        Iterator<E> descendingIterator();
        NavigableSet<E> subSet(E fromElement, boolean fromInclusive,
                            E toElement,   boolean toInclusive);
        NavigableSet<E> headSet(E toElement, boolean inclusive);
        NavigableSet<E> tailSet(E fromElement, boolean inclusive);
        SortedSet<E> subSet(E fromElement, E toElement);
        SortedSet<E> headSet(E toElement);
        SortedSet<E> tailSet(E fromElement);
    }
    ```
- TreeMap(红黑树)
    ```java
    public V put(K key, V value) {
        Entry<K,V> t = root;
        if (t == null) {
            compare(key, key);
            root = new Entry<>(key, value, null);
            size = 1;
            modCount++;
            return null;
        }
        int cmp;
        Entry<K,V> parent;
        Comparator<? super K> cpr = comparator;
        if (cpr != null) {
            do {
                parent = t;
                cmp = cpr.compare(key, t.key);
                if (cmp < 0)  // 小于
                    t = t.left;
                else if (cmp > 0) // 大于
                    t = t.right;
                else  // 等于
                    return t.setValue(value);
            } while (t != null);
        }
        else {
            if (key == null)
                throw new NullPointerException();
            @SuppressWarnings("unchecked")
                Comparable<? super K> k = (Comparable<? super K>) key;
            do {
                parent = t;
                cmp = k.compareTo(t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        }
        Entry<K,V> e = new Entry<>(key, value, parent);
        if (cmp < 0)
            parent.left = e;
        else
            parent.right = e;
        fixAfterInsertion(e);  // 插入修复红黑树
        size++;
        modCount++;
        return null;
    }
    // 没看懂,也不想看
    private void fixAfterInsertion(Entry<K,V> x) {
        x.color = RED;
        while (x != null && x != root && x.parent.color == RED) {
            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
                Entry<K,V> y = rightOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == rightOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateLeft(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateRight(parentOf(parentOf(x)));
                }
            } else {
                Entry<K,V> y = leftOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == leftOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateRight(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateLeft(parentOf(parentOf(x)));
                }
            }
        }
        root.color = BLACK;
    }
    ```
- TreeSet
    ```java
    ublic class TreeSet<E> extends AbstractSet<E> implements NavigableSet<E>, Cloneable, java.io.Serializable {
        // 实际内部容器
        private transient NavigableMap<E,Object> m;
        // Dummy value to associate with an Object in the backing Map
       private static final Object PRESENT = new Object();
    }
    ```