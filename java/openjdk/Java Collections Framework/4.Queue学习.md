# java.util.Queue学习
- 相关接口申明
    ```java
    public interface Queue<E> extends Collection<E> {
        // Throws exception
        boolean add(E e);
        E remove();
        E element();
        // Returns special value
        boolean offer(E e);    
        E poll();    
        E peek();
    }
    public interface Deque<E> extends Queue<E> {
        // Throws exception
        void addFirst(E e);
        void addLast(E e);
        E removeFirst();
        E removeLast();
        E getFirst();
        E getLast();
        // Returns special value
        boolean offerFirst(E e);
        boolean offerLast(E e);
        E pollFirst();
        E pollLast();
        E peekFirst();
        E peekLast();
        boolean removeFirstOccurrence(Object o);
        boolean removeLastOccurrence(Object o);
    }
    ```
- 相关实现类部分代码
    ```java
    // 无限制(最大不超过数组限制), 添加不会抛异常
    public class ArrayDeque<E> extends AbstractCollection<E> implements Deque<E>, Cloneable, Serializable {
        // 数据表示:  tail                          head
        //           [0]  [1] [2] ... [n-3] [n-2] [n-1] 
        // 不支持null元素, 必须有一个元素为null作为一个预占用(用于确定头部、尾部是否重合, 是否需要扩容)
        // 数组头为列表尾部
        transient Object[] elements;
        // 双端队列头部索引
        transient int head;
        // 双端队列尾部索引
        transient int tail;
        // 默认保存16个元素
        public ArrayDeque() {
            elements = new Object[16 + 1];
        }
        // 双端链表操作主要靠索引计算完成
        // Circularly increments i, mod modulus
        static final int inc(int i, int modulus) {
            if (++i >= modulus) i = 0;
            return i;
        }
        // Circularly decrements i, mod modulus.
        static final int dec(int i, int modulus) {
            if (--i < 0) i = modulus - 1;
            return i;
        }
        // Circularly adds the given distance to index i, mod modulus
        static final int inc(int i, int distance, int modulus) {
            if ((i += distance) - modulus >= 0) i -= modulus;
            return i;
        }
        // Subtracts j from i, mod modulus
        static final int sub(int i, int j, int modulus) {
            if ((i -= j) < 0) i += modulus;
            return i;
        }
        // The main insertion and extraction methods
        public void addFirst(E e) {
            if (e == null) throw new NullPointerException();
            final Object[] es = elements;
            es[head = dec(head, es.length)] = e;
            if (head == tail)
                grow(1);
        }
        public void addLast(E e) {
            if (e == null) throw new NullPointerException();
            final Object[] es = elements;
            es[tail] = e;
            if (head == (tail = inc(tail, es.length)))
                grow(1);
        }
        // 按需要扩容容量扩容
        private void grow(int needed) {
            // overflow-conscious code
            final int oldCapacity = elements.length;
            int newCapacity;
            // 原来容量小于64扩容原来一倍, 否则50%
            int jump = (oldCapacity < 64) ? (oldCapacity + 2) : (oldCapacity >> 1);
            if (jump < needed
                || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE > 0)
                newCapacity = newCapacity(needed, jump);
            final Object[] es = elements = Arrays.copyOf(elements, newCapacity);
            // Exceptionally, here tail == head needs to be disambiguated
            if (tail < head || (tail == head && es[head] != null)) {
                // wrap around; slide first leg forward to end of array
                int newSpace = newCapacity - oldCapacity;
                System.arraycopy(es, head,
                                es, head + newSpace,
                                oldCapacity - head);
                for (int i = head, to = (head += newSpace); i < to; i++)
                    es[i] = null;
            }
        }
        // Capacity calculation for edge conditions, especially overflow
        private int newCapacity(int needed, int jump) {
            final int oldCapacity = elements.length, minCapacity;
            if ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE > 0) {
                if (minCapacity < 0)
                    throw new IllegalStateException("Sorry, deque too big");
                return Integer.MAX_VALUE;
            }
            if (needed > jump)
                return minCapacity;
            return (oldCapacity + jump - MAX_ARRAY_SIZE < 0)
                ? oldCapacity + jump
                : MAX_ARRAY_SIZE;
        }
        public boolean removeFirstOccurrence(Object o) {
            if (o != null) {
                final Object[] es = elements;
                for (int i = head, end = tail, to = (i <= end) ? end : es.length;
                    ; i = 0, to = end) {
                    for (; i < to; i++)
                        if (o.equals(es[i])) {
                            delete(i);
                            return true;
                        }
                    if (to == end) break;
                }
            }
            return false;
        }
        public boolean removeLastOccurrence(Object o) {
            if (o != null) {
                final Object[] es = elements;
                for (int i = tail, end = head, to = (i >= end) ? end : 0;
                    ; i = es.length, to = end) {
                    for (i--; i > to - 1; i--)
                        if (o.equals(es[i])) {
                            delete(i);
                            return true;
                        }
                    if (to == end) break;
                }
            }
            return false;
        }
        // Removes the element at the specified position in the elements array
        boolean delete(int i) {
            final Object[] es = elements;
            final int capacity = es.length;
            final int h, t;
            // number of elements before to-be-deleted elt
            final int front = sub(i, h = head, capacity);
            // number of elements after to-be-deleted elt
            final int back = sub(t = tail, i, capacity) - 1;
            if (front < back) {
                // move front elements forwards
                if (h <= i) {
                    System.arraycopy(es, h, es, h + 1, front);
                } else { // Wrap around
                    System.arraycopy(es, 0, es, 1, i);
                    es[0] = es[capacity - 1];
                    System.arraycopy(es, h, es, h + 1, front - (i + 1));
                }
                es[h] = null;
                head = inc(h, capacity);
                return false;
            } else {
                // move back elements backwards
                tail = dec(t, capacity);
                if (i <= tail) {
                    System.arraycopy(es, i + 1, es, i, back);
                } else { // Wrap around
                    System.arraycopy(es, i + 1, es, i, capacity - (i + 1));
                    es[capacity - 1] = es[0];
                    System.arraycopy(es, 1, es, 0, t - 1);
                }
                es[tail] = null;
                return true;
            }
        }
        /** Implementation of bulk remove methods. */
        private boolean bulkRemove(Predicate<? super E> filter) {
            final Object[] es = elements;
            // Optimize for initial run of survivors
            for (int i = head, end = tail, to = (i <= end) ? end : es.length;
                ; i = 0, to = end) {
                for (; i < to; i++)
                    if (filter.test(elementAt(es, i)))
                        return bulkRemoveModified(filter, i);
                if (to == end) {
                    if (end != tail) throw new ConcurrentModificationException();
                    break;
                }
            }
            return false;
        }
        // Spliterator实现
        final class DeqSpliterator implements Spliterator<E> {
            private int fence;      // -1 until first use
            private int cursor;     // current index, modified on traverse/split
            /** Constructs late-binding spliterator over all elements. */
            DeqSpliterator() {
                this.fence = -1;
            }
            /** Constructs spliterator over the given range. */
            DeqSpliterator(int origin, int fence) {
                // assert 0 <= origin && origin < elements.length;
                // assert 0 <= fence && fence < elements.length;
                this.cursor = origin;
                this.fence = fence;
            }
            /** Ensures late-binding initialization; then returns fence. */
            private int getFence() { // force initialization
                int t;
                if ((t = fence) < 0) {
                    t = fence = tail;
                    cursor = head;
                }
                return t;
            }
            public DeqSpliterator trySplit() {
                final Object[] es = elements;
                final int i, n;
                return ((n = sub(getFence(), i = cursor, es.length) >> 1) <= 0)
                    ? null
                    : new DeqSpliterator(i, cursor = inc(i, n, es.length));
            }
            public void forEachRemaining(Consumer<? super E> action) {
                if (action == null) throw new NullPointerException();
                final int end = getFence(), cursor = this.cursor;
                final Object[] es = elements;
                if (cursor != end) {
                    this.cursor = end;
                    // null check at both ends of range is sufficient
                    if (es[cursor] == null || es[dec(end, es.length)] == null)
                        throw new ConcurrentModificationException();
                    for (int i = cursor, to = (i <= end) ? end : es.length;
                        ; i = 0, to = end) {
                        for (; i < to; i++)
                            action.accept(elementAt(es, i));
                        if (to == end) break;
                    }
                }
            }
            public boolean tryAdvance(Consumer<? super E> action) {
                Objects.requireNonNull(action);
                final Object[] es = elements;
                if (fence < 0) { fence = tail; cursor = head; } // late-binding
                final int i;
                if ((i = cursor) == fence)
                    return false;
                E e = nonNullElementAt(es, i);
                cursor = inc(i, es.length);
                action.accept(e);
                return true;
            }
            public long estimateSize() {
                return sub(getFence(), cursor, elements.length);
            }
            public int characteristics() {
                return Spliterator.NONNULL
                    | Spliterator.ORDERED
                    | Spliterator.SIZED
                    | Spliterator.SUBSIZED;
            }
        }
    }
    ```