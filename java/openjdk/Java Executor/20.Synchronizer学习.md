# Synchronizer学习
- 相关实现
    ```java
    public abstract class AbstractOwnableSynchronizer implements java.io.Serializable {
        // 线程排他比较依据
        private transient Thread exclusiveOwnerThread;
        protected final void setExclusiveOwnerThread(Thread thread) {
            exclusiveOwnerThread = thread;
        }
        protected final Thread getExclusiveOwnerThread() {
            return exclusiveOwnerThread;
        }
    }
    public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
        /**
        * CLH(Craig, Landin, and  Hagersten) lock queue
        *
        *      +------+  prev +-----+       +-----+
        * head |      | <---- |     | <---- |     |  tail
        *      +------+       +-----+       +-----+
        * waitStatus(用来判断当前及之后节点应该进行的操作):
        *   CANCELLED(1):  当前节点已被取消
        *   SIGNAL  (-1):  下一个节点已被阻塞(park), 释放时需激活(unpark)
        *   CONDITION(-2): 当前节点处在condition状态
        *   PROPAGATE(-3): 当前节点处在SharedReleased状态
        *             (0): None of the above
        */
        static final class Node {
            static {
                try {
                    MethodHandles.Lookup l = MethodHandles.lookup();
                    NEXT       = l.findVarHandle(Node.class, "next", Node.class);
                    PREV       = l.findVarHandle(Node.class, "prev", Node.class);
                    THREAD     = l.findVarHandle(Node.class, "thread", Thread.class);
                    WAITSTATUS = l.findVarHandle(Node.class, "waitStatus", int.class);
                } catch (ReflectiveOperationException e) {
                    throw new ExceptionInInitializerError(e);
                }
            }
            volatile int waitStatus;
            volatile Node prev;
            volatile Node next;
            volatile Thread thread;
            static final Node SHARED = new Node();
            static final Node EXCLUSIVE = null;
            static final int CANCELLED =  1;
            static final int SIGNAL    = -1;
            static final int CONDITION = -2;
            static final int PROPAGATE = -3;
            Node nextWaiter;
            final boolean isShared() { return nextWaiter == SHARED; }
            final Node predecessor() {
                Node p = prev;
                if (p == null) throw new NullPointerException();
                else return p;
            }
        }
        static {
            try {
                MethodHandles.Lookup l = MethodHandles.lookup();
                STATE = l.findVarHandle(AbstractQueuedSynchronizer.class, "state", int.class);
                HEAD  = l.findVarHandle(AbstractQueuedSynchronizer.class, "head", Node.class);
                TAIL  = l.findVarHandle(AbstractQueuedSynchronizer.class, "tail", Node.class);
            } catch (ReflectiveOperationException e) {
                throw new ExceptionInInitializerError(e);
            }
            Class<?> ensureLoaded = LockSupport.class;
        }
        private transient volatile Node head;
        private transient volatile Node tail;
        private volatile int state;
        /*
         * 子类需要实现的方法
         */
        // 获取同步器(只能由一个线程获取)
        protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); }
        // 释放同步器(只能由一个线程获取)
        protected boolean tryRelease(int arg) { throw new UnsupportedOperationException(); }
        // 获取同步器(多个线程获取)
        protected int tryAcquireShared(int arg) { throw new UnsupportedOperationException(); }
        // 释放同步器(多个线程获取)
        protected boolean tryReleaseShared(int arg) { throw new UnsupportedOperationException(); }
        // 同步器是否线程排他
        protected boolean isHeldExclusively() { throw new UnsupportedOperationException(); }
        /*
         * 同步器使用的方法
         */
        public final void acquire(int arg) {
            if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                selfInterrupt();
        }
        public final void acquireInterruptibly(int arg) throws InterruptedException {
            if (Thread.interrupted()) throw new InterruptedException();
            if (!tryAcquire(arg)) doAcquireInterruptibly(arg);
        }
        public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {
            if (Thread.interrupted()) throw new InterruptedException();
            return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);
        }
        public final boolean release(int arg) {
            if (tryRelease(arg)) {
                Node h = head;
                if (h != null && h.waitStatus != 0) unparkSuccessor(h);
                return true;
            }
            return false;
        }
        public final void acquireShared(int arg) {
            if (tryAcquireShared(arg) < 0) doAcquireShared(arg);
        }
        public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
            if (Thread.interrupted()) throw new InterruptedException();
            if (tryAcquireShared(arg) < 0) doAcquireSharedInterruptibly(arg);
        }
        public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException {
            if (Thread.interrupted()) throw new InterruptedException();
            return tryAcquireShared(arg) >= 0 || doAcquireSharedNanos(arg, nanosTimeout);
        }
        public final boolean releaseShared(int arg) {
            if (tryReleaseShared(arg)) {
                doReleaseShared();
                return true;
            }
            return false;
        }
        // 添加入队列尾部节点等待同步器
        private Node addWaiter(Node mode) {
            Node node = new Node(mode);
            for (;;) {
                Node oldTail = tail;
                if (oldTail != null) {
                    node.setPrevRelaxed(oldTail);
                    if (compareAndSetTail(oldTail, node)) {
                        oldTail.next = node;
                        return node;
                    }
                } else {
                    initializeSyncQueue();
                }
            }
        }
        private final void initializeSyncQueue() {
            Node h;
            if (HEAD.compareAndSet(this, null, (h = new Node()))) tail = h;
        }
        // 队列阻塞, 直到获取或中断
        final boolean acquireQueued(final Node node, int arg) {
            boolean interrupted = false;
            try {
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head && tryAcquire(arg)) {
                        setHead(node);
                        p.next = null; // help GC
                        return interrupted;
                    }
                    if (shouldParkAfterFailedAcquire(p, node))
                        interrupted |= parkAndCheckInterrupt();
                }
            } catch (Throwable t) {
                cancelAcquire(node);
                if (interrupted) selfInterrupt();
                throw t;
            }
        }
        // 类似, 但具体细节不一样
        private void doAcquireInterruptibly(int arg) throws InterruptedException {
            final Node node = addWaiter(Node.EXCLUSIVE);
            try {
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head && tryAcquire(arg)) {
                        setHead(node);
                        p.next = null; // help GC
                        return;
                    }
                    if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) throw new InterruptedException();
                }
            } catch (Throwable t) {
                cancelAcquire(node);
                throw t;
            }
        }
        // 设置超时
        private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {
            if (nanosTimeout <= 0L) return false;
            final long deadline = System.nanoTime() + nanosTimeout;
            final Node node = addWaiter(Node.EXCLUSIVE);
            try {
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head && tryAcquire(arg)) {
                        setHead(node);
                        p.next = null; // help GC
                        return true;
                    }
                    nanosTimeout = deadline - System.nanoTime();
                    if (nanosTimeout <= 0L) {
                        cancelAcquire(node);
                        return false;
                    }
                    if (shouldParkAfterFailedAcquire(p, node) && nanosTimeout > SPIN_FOR_TIMEOUT_THRESHOLD)
                        LockSupport.parkNanos(this, nanosTimeout);
                    if (Thread.interrupted()) throw new InterruptedException();
                }
            } catch (Throwable t) {
                cancelAcquire(node);
                throw t;
            }
        }
        // 获取线程共享同步器
        private void doAcquireShared(int arg) {
            final Node node = addWaiter(Node.SHARED);
            boolean interrupted = false;
            try {
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head) {
                        int r = tryAcquireShared(arg);
                        if (r >= 0) {
                            setHeadAndPropagate(node, r);
                            p.next = null; // help GC
                            return;
                        }
                    }
                    if (shouldParkAfterFailedAcquire(p, node))
                        interrupted |= parkAndCheckInterrupt();
                }
            } catch (Throwable t) {
                cancelAcquire(node);
                throw t;
            } finally {
                if (interrupted) selfInterrupt();
            }
        }
        private void doAcquireSharedInterruptibly(int arg) throws InterruptedException {
            final Node node = addWaiter(Node.SHARED);
            try {
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head) {
                        int r = tryAcquireShared(arg);
                        if (r >= 0) {
                            setHeadAndPropagate(node, r);
                            p.next = null; // help GC
                            return;
                        }
                    }
                    if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                        throw new InterruptedException();
                }
            } catch (Throwable t) {
                cancelAcquire(node);
                throw t;
            }
        }
        private boolean doAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException {
            if (nanosTimeout <= 0L) return false;
            final long deadline = System.nanoTime() + nanosTimeout;
            final Node node = addWaiter(Node.SHARED);
            try {
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head) {
                        int r = tryAcquireShared(arg);
                        if (r >= 0) {
                            setHeadAndPropagate(node, r);
                            p.next = null; // help GC
                            return true;
                        }
                    }
                    nanosTimeout = deadline - System.nanoTime();
                    if (nanosTimeout <= 0L) {
                        cancelAcquire(node);
                        return false;
                    }
                    if (shouldParkAfterFailedAcquire(p, node) && nanosTimeout > SPIN_FOR_TIMEOUT_THRESHOLD)
                        LockSupport.parkNanos(this, nanosTimeout);
                    if (Thread.interrupted()) throw new InterruptedException();
                }
            } catch (Throwable t) {
                cancelAcquire(node);
                throw t;
            }
        }
        private void unparkSuccessor(Node node) {
            int ws = node.waitStatus;
            if (ws < 0) node.compareAndSetWaitStatus(ws, 0);
            Node s = node.next;
            if (s == null || s.waitStatus > 0) {
                s = null;
                for (Node p = tail; p != node && p != null; p = p.prev)
                    if (p.waitStatus <= 0) s = p;
            }
            if (s != null) LockSupport.unpark(s.thread);
        }
        private void doReleaseShared() {
            for (;;) {
                Node h = head;
                if (h != null && h != tail) {
                    int ws = h.waitStatus;
                    if (ws == Node.SIGNAL) {
                        if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0)) continue;            // loop to recheck cases
                        unparkSuccessor(h);
                    }
                    else if (ws == 0 && !h.compareAndSetWaitStatus(0, Node.PROPAGATE))
                        continue;                // loop on failed CAS
                }
                if (h == head)                   // loop if head changed
                    break;
            }
        }
        private void setHeadAndPropagate(Node node, int propagate) {
            Node h = head; // Record old head for check below
            setHead(node);
            if (propagate > 0 || h == null || h.waitStatus < 0 ||
                (h = head) == null || h.waitStatus < 0) {
                Node s = node.next;
                if (s == null || s.isShared())
                    doReleaseShared();
            }
        }
        private void cancelAcquire(Node node) {
            if (node == null) return;
            node.thread = null;
            Node pred = node.prev;
            while (pred.waitStatus > 0) node.prev = pred = pred.prev;
            Node predNext = pred.next;
            node.waitStatus = Node.CANCELLED;
            if (node == tail && compareAndSetTail(node, pred)) {
                pred.compareAndSetNext(predNext, null);
            } else {
                int ws;
                if (pred != head &&
                    ((ws = pred.waitStatus) == Node.SIGNAL ||
                    (ws <= 0 && pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &&
                    pred.thread != null) {
                    Node next = node.next;
                    if (next != null && next.waitStatus <= 0)
                        pred.compareAndSetNext(predNext, next);
                } else {
                    unparkSuccessor(node);
                }
                node.next = node; // help GC
            }
        }
        private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
            int ws = pred.waitStatus;
            if (ws == Node.SIGNAL) return true;
            if (ws > 0) {
                do {
                    node.prev = pred = pred.prev;
                } while (pred.waitStatus > 0);
                pred.next = node;
            } else {
                pred.compareAndSetWaitStatus(ws, Node.SIGNAL);
            }
            return false;
        }
    }
    ```
- 实际使用的public final模板方法
    ```java
    /* 排他模式 */
    public final void    acquire(int arg);
    public final void    acquireInterruptibly(int arg);
    public final boolean tryAcquireNanos(int arg, long nanosTimeout);
    public final boolean release(int arg);
    /* 共享模式 */
    public final void    acquireShared(int arg);
    public final void    acquireSharedInterruptibly(int arg);
    public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout);
    public final boolean releaseShared(int arg);
    ```