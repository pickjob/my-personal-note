# Executor框架学习
- 相关接口申明
    ```java
    public interface Executor {
        void execute(Runnable command);
    }
    // 任务生命周期管理
    public interface ExecutorService extends Executor {
        // 生命周期相关
        void                shutdown(); // 已提交执行完成, 拒绝再提交的任务
        List<Runnable>      shutdownNow(); // 立刻结束
        boolean             isShutdown();
        boolean             isTerminated();
        boolean             awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; // 等待所有任务结束
        // 提交任务
        <T> Future<T>       submit(Callable<T> task);
        <T> Future<T>       submit(Runnable task, T result);
        Future<?>           submit(Runnable task);
        // 调用任务, 返回Future追踪任务
        <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
        <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException;
        // 调用任务, 返回一个完成且成功的返回值
        <T> T               invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;
        <T> T               invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException,ExecutionException, TimeoutException;
    }
    // 定时任务
    public interface ScheduledExecutorService extends ExecutorService {
        public ScheduledFuture<?>     schedule(Runnable command, long delay, TimeUnit unit);
        public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit);
        public ScheduledFuture<?>     scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);
        public ScheduledFuture<?>     scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);
    }
    @FunctionalInterface public interface Runnable {
        public abstract void run();
    }
    @FunctionalInterface public interface Callable<V> {
        V call() throws Exception;
    }
    public interface Delayed extends Comparable<Delayed> {
        long getDelay(TimeUnit unit);
    }
    public interface Future<V> {
        // 获得或改变任务完成度方法
        boolean isDone();
        boolean isCancelled();
        boolean cancel(boolean mayInterruptIfRunning);
        // 获得任务结果
        V get() throws InterruptedException, ExecutionException;
        V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
    }
    public interface RunnableFuture<V> extends Runnable, Future<V> {
        void run();
    }
    public interface ScheduledFuture<V> extends Delayed, Future<V> {}
    public interface RunnableScheduledFuture<V> extends RunnableFuture<V>, ScheduledFuture<V> {
        boolean isPeriodic();
    }
    public interface ThreadFactory {
        Thread newThread(Runnable r);
    }
    public interface RejectedExecutionHandler {
        void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
    }
    // 返回已完成的Task结果Future
    public interface CompletionService<V> {
        // 提交任务
        Future<V> submit(Callable<V> task);
        Future<V> submit(Runnable task, V result);
        // 获得已完成任务的Future
        Future<V> poll();
        Future<V> poll(long timeout, TimeUnit unit) throws InterruptedException;
        Future<V> take() throws InterruptedException;
    }
    public interface CompletionStage<T> {
        public <U> CompletionStage<U> thenApply(Function<? super T,? extends U> fn);
        public <U> CompletionStage<U> thenApplyAsync (Function<? super T,? extends U> fn);
        public <U> CompletionStage<U> thenApplyAsync (Function<? super T,? extends U> fn, Executor executor);
        public CompletionStage<Void> thenAccept(Consumer<? super T> action);
        public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action);
        public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor);
        public CompletionStage<Void> thenRun(Runnable action);
        public CompletionStage<Void> thenRunAsync(Runnable action);
        public CompletionStage<Void> thenRunAsync(Runnable action, Executor executor);
        public <U,V> CompletionStage<V> thenCombine (CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);
        public <U,V> CompletionStage<V> thenCombineAsync (CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);
        public <U,V> CompletionStage<V> thenCombineAsync (CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn, Executor executor);
        public <U> CompletionStage<Void> thenAcceptBoth (CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);
        public <U> CompletionStage<Void> thenAcceptBothAsync (CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);
        public <U> CompletionStage<Void> thenAcceptBothAsync (CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action, Executor executor);
        public CompletionStage<Void> runAfterBoth(CompletionStage<?> other, Runnable action);
        public CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action);
        public CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action, Executor executor);
        public <U> CompletionStage<U> applyToEither (CompletionStage<? extends T> other, Function<? super T, U> fn);
        public <U> CompletionStage<U> applyToEitherAsync (CompletionStage<? extends T> other, Function<? super T, U> fn);
        public <U> CompletionStage<U> applyToEitherAsync (CompletionStage<? extends T> other, Function<? super T, U> fn, Executor executor);
        public CompletionStage<Void> acceptEither (CompletionStage<? extends T> other, Consumer<? super T> action);
        public CompletionStage<Void> acceptEitherAsync (CompletionStage<? extends T> other, Consumer<? super T> action);
        public CompletionStage<Void> acceptEitherAsync (CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor);
        public CompletionStage<Void> runAfterEither(CompletionStage<?> other, Runnable action);
        public CompletionStage<Void> runAfterEitherAsync (CompletionStage<?> other, Runnable action);
        public CompletionStage<Void> runAfterEitherAsync (CompletionStage<?> other, Runnable action, Executor executor);
        public <U> CompletionStage<U> thenCompose (Function<? super T, ? extends CompletionStage<U>> fn);
        public <U> CompletionStage<U> thenComposeAsync (Function<? super T, ? extends CompletionStage<U>> fn);
        public <U> CompletionStage<U> thenComposeAsync (Function<? super T, ? extends CompletionStage<U>> fn, Executor executor);
        public <U> CompletionStage<U> handle (BiFunction<? super T, Throwable, ? extends U> fn);
        public <U> CompletionStage<U> handleAsync (BiFunction<? super T, Throwable, ? extends U> fn);
        public <U> CompletionStage<U> handleAsync (BiFunction<? super T, Throwable, ? extends U> fn, Executor executor);
        public CompletionStage<T> whenComplete (BiConsumer<? super T, ? super Throwable> action);
        public CompletionStage<T> whenCompleteAsync (BiConsumer<? super T, ? super Throwable> action);
        public CompletionStage<T> whenCompleteAsync (BiConsumer<? super T, ? super Throwable> action, Executor executor);
        public CompletionStage<T> exceptionally (Function<Throwable, ? extends T> fn);
        public default CompletionStage<T> exceptionallyAsync (Function<Throwable, ? extends T> fn) {
            return handle((r, ex) -> (ex == null)
                        ? this
                        : this.<T>handleAsync((r1, ex1) -> fn.apply(ex1)))
                .thenCompose(Function.identity());
        }
        public default CompletionStage<T> exceptionallyAsync
            (Function<Throwable, ? extends T> fn, Executor executor) {
            return handle((r, ex) -> (ex == null)
                        ? this
                        : this.<T>handleAsync((r1, ex1) -> fn.apply(ex1), executor))
                .thenCompose(Function.identity());
        }
        public default CompletionStage<T> exceptionallyCompose
            (Function<Throwable, ? extends CompletionStage<T>> fn) {
            return handle((r, ex) -> (ex == null)
                        ? this
                        : fn.apply(ex))
                .thenCompose(Function.identity());
        }
        public default CompletionStage<T> exceptionallyComposeAsync
            (Function<Throwable, ? extends CompletionStage<T>> fn) {
            return handle((r, ex) -> (ex == null)
                        ? this
                        : this.handleAsync((r1, ex1) -> fn.apply(ex1))
                            .thenCompose(Function.identity()))
                .thenCompose(Function.identity());
        }
        public default CompletionStage<T> exceptionallyComposeAsync
            (Function<Throwable, ? extends CompletionStage<T>> fn,
            Executor executor) {
            return handle((r, ex) -> (ex == null)
                        ? this
                        : this.handleAsync((r1, ex1) -> fn.apply(ex1), executor)
                            .thenCompose(Function.identity()))
                .thenCompose(Function.identity());
        }
        public CompletableFuture<T> toCompletableFuture();

    }
    ```
- 相关实现类
    ```java
    //      线程设置:
    //          Core and maximum pool sizes
    //          On-demand construction
    //          Creating new threads
    //          Keep-alive times
    //          Queuing:
    //              Direct handoffs
    //              Unbounded queue
    //              Bounded queue
    //          Rejected tasks(已关闭或者超限):
    //              ThreadPoolExecutor.AbortPolicy
    //              ThreadPoolExecutor.CallerRunsPolicy
    //              ThreadPoolExecutor.DiscardPolicy
    //              ThreadPoolExecutor.DiscardOldestPolicy
    //          Hook methods
    //              beforeExecute(Thread, Runnable)
    //              afterExecute(Runnable, Throwable)
    //          Queue maintenance
    public class ThreadPoolExecutor extends AbstractExecutorService {
        // ctl:
        //      workerCount(29bit) indicating the effective number of threads
        //      runState(3bit)     indicating whether running, shutting down etc
        // runState
        //      RUNNING:    Accept new tasks and process queued tasks
        //      SHUTDOWN:   Don't accept new tasks, but process queued tasks
        //      STOP:       Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks
        //      TIDYING:    All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method
        //      TERMINATED: terminated() has completed
        //
        //      RUNNING                 ->      SHUTDOWN:   On invocation of shutdown()
        //      (RUNNING or SHUTDOWN)   ->      STOP:       On invocation of shutdownNow()
        //      SHUTDOWN                ->      TIDYING:    When both queue and pool are empty
        //      STOP                    ->      TIDYING:    When pool is empty
        //      TIDYING                 ->      TERMINATED: When the terminated() hook method has completed
        private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
        // 默认队列拒绝会抛异常
        private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
        // 添加任务
        public void execute(Runnable command) {
            if (command == null) throw new NullPointerException();
            /*
            * Proceed in 3 steps:
            * 1. 实际数小于限定数, 增加线程
            * 2. 加入任务队列
            * 3. 不能加入成功重新尝试增加线程
            */
            int c = ctl.get();
            if (workerCountOf(c) < corePoolSize) {
                if (addWorker(command, true)) return;
                c = ctl.get();
            }
            if (isRunning(c) && workQueue.offer(command)) {
                int recheck = ctl.get();
                if (! isRunning(recheck) && remove(command)) reject(command);
                else if (workerCountOf(recheck) == 0) addWorker(null, false);
            }
            else if (!addWorker(command, false)) reject(command);
        }
    }
    public class FutureTask<V> implements RunnableFuture<V> {
        /**
        * Possible state transitions:
        *   NEW -> COMPLETING -> NORMAL
        *   NEW -> COMPLETING -> EXCEPTIONAL
        *   NEW -> CANCELLED
        *   NEW -> INTERRUPTING -> INTERRUPTED
        */
        private volatile int state;
        // 记录真正执行的线程, 为了后期interrupt
        private volatile Thread runner;
        // 真正执行逻辑, 记录结果和状态
        public void run() {
            if (state != NEW || !RUNNER.compareAndSet(this, null, Thread.currentThread())) return;
            try {
                Callable<V> c = callable;
                if (c != null && state == NEW) {
                    V result;
                    boolean ran;
                    try {
                        result = c.call();
                        ran = true;
                    } catch (Throwable ex) {
                        result = null;
                        ran = false;
                        setException(ex);
                    }
                    if (ran) set(result);
                }
            } finally {
                // runner must be non-null until state is settled to
                // prevent concurrent calls to run()
                runner = null;
                // state must be re-read after nulling runner to prevent
                // leaked interrupts
                int s = state;
                if (s >= INTERRUPTING)
                    handlePossibleCancellationInterrupt(s);
            }
        }
    }
    ```
- 工具类实现
    ```java
    public class Executors {
        //  A callable that runs given task and returns given result
        private static final class RunnableAdapter<T> implements Callable<T> {
            private final Runnable task;
            private final T result;
            RunnableAdapter(Runnable task, T result) {
                this.task = task;
                this.result = result;
            }
            public T call() {
                task.run();
                return result;
            }
            public String toString() {
                return super.toString() + "[Wrapped task = " + task + "]";
            }
        }
        // A callable that runs under established access control settings
        private static final class PrivilegedCallable<T> implements Callable<T> {
            final Callable<T> task;
            final AccessControlContext acc;
            PrivilegedCallable(Callable<T> task) {
                this.task = task;
                this.acc = AccessController.getContext();
            }
            public T call() throws Exception {
                try {
                    return AccessController.doPrivileged(
                        new PrivilegedExceptionAction<T>() {
                            public T run() throws Exception {
                                return task.call();
                            }
                        }, acc);
                } catch (PrivilegedActionException e) {
                    throw e.getException();
                }
            }
            public String toString() {
                return super.toString() + "[Wrapped task = " + task + "]";
            }
        }
        // A callable that runs under established access control settings and current ClassLoader
        private static final class PrivilegedCallableUsingCurrentClassLoader<T>
                implements Callable<T> {
            final Callable<T> task;
            final AccessControlContext acc;
            final ClassLoader ccl;
            PrivilegedCallableUsingCurrentClassLoader(Callable<T> task) {
                SecurityManager sm = System.getSecurityManager();
                if (sm != null) {
                    // Calls to getContextClassLoader from this class
                    // never trigger a security check, but we check
                    // whether our callers have this permission anyways.
                    sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);

                    // Whether setContextClassLoader turns out to be necessary
                    // or not, we fail fast if permission is not available.
                    sm.checkPermission(new RuntimePermission("setContextClassLoader"));
                }
                this.task = task;
                this.acc = AccessController.getContext();
                this.ccl = Thread.currentThread().getContextClassLoader();
            }
            public T call() throws Exception {
                try {
                    return AccessController.doPrivileged(
                        new PrivilegedExceptionAction<T>() {
                            public T run() throws Exception {
                                Thread t = Thread.currentThread();
                                ClassLoader cl = t.getContextClassLoader();
                                if (ccl == cl) {
                                    return task.call();
                                } else {
                                    t.setContextClassLoader(ccl);
                                    try {
                                        return task.call();
                                    } finally {
                                        t.setContextClassLoader(cl);
                                    }
                                }
                            }
                        }, acc);
                } catch (PrivilegedActionException e) {
                    throw e.getException();
                }
            }
            public String toString() {
                return super.toString() + "[Wrapped task = " + task + "]";
            }
        }
        // The default thread factory
        private static class DefaultThreadFactory implements ThreadFactory {
            private static final AtomicInteger poolNumber = new AtomicInteger(1);
            private final ThreadGroup group;
            private final AtomicInteger threadNumber = new AtomicInteger(1);
            private final String namePrefix;
            DefaultThreadFactory() {
                SecurityManager s = System.getSecurityManager();
                group = (s != null) ? s.getThreadGroup() :
                                    Thread.currentThread().getThreadGroup();
                namePrefix = "pool-" +
                            poolNumber.getAndIncrement() +
                            "-thread-";
            }
            public Thread newThread(Runnable r) {
                Thread t = new Thread(group, r,
                                    namePrefix + threadNumber.getAndIncrement(),
                                    0);
                if (t.isDaemon())
                    t.setDaemon(false);
                if (t.getPriority() != Thread.NORM_PRIORITY)
                    t.setPriority(Thread.NORM_PRIORITY);
                return t;
            }
        }
    }
    ```