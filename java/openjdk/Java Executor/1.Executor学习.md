# Executor框架学习
- 相关接口申明
    ```java
    public interface Executor {
        void execute(Runnable command);
    }
    // 任务生命周期管理
    public interface ExecutorService extends Executor {
        // 生命周期相关
        void                shutdown(); // 已提交执行完成, 拒绝再提交的任务
        List<Runnable>      shutdownNow(); // 立刻结束
        boolean             isShutdown();
        boolean             isTerminated();
        boolean             awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; // 等待所有任务结束
        // 提交任务
        <T> Future<T>       submit(Callable<T> task);
        <T> Future<T>       submit(Runnable task, T result);
        Future<?>           submit(Runnable task);
        // 调用任务, 返回Future追踪任务
        <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
        <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException;
        // 调用任务, 返回一个完成且成功的返回值
        <T> T               invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;
        <T> T               invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException,ExecutionException, TimeoutException;
    }
    // 定时任务
    public interface ScheduledExecutorService extends ExecutorService {
        public ScheduledFuture<?>     schedule(Runnable command, long delay, TimeUnit unit);
        public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit);
        public ScheduledFuture<?>     scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);
        public ScheduledFuture<?>     scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);
    }
    // 返回已完成的Task结果Future
    public interface CompletionService<V> {
        // 提交任务
        Future<V> submit(Callable<V> task);
        Future<V> submit(Runnable task, V result);
        // 获得已完成任务的Future
        Future<V> poll();
        Future<V> poll(long timeout, TimeUnit unit) throws InterruptedException;
        Future<V> take() throws InterruptedException;
    }
    @FunctionalInterface public interface Runnable {
        public abstract void run();
    }
    @FunctionalInterface public interface Callable<V> {
        V call() throws Exception;
    }
    public interface Future<V> {
        // 尝试取消任务
        boolean cancel(boolean mayInterruptIfRunning);
        boolean isCancelled();
        boolean isDone();
        // 获得任务结果
        V get() throws InterruptedException, ExecutionException;
        V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
    }
    public interface RunnableFuture<V> extends Runnable, Future<V> {
        void run();
    }
    public interface ScheduledFuture<V> extends Delayed, Future<V> {}
    public interface RunnableScheduledFuture<V> extends RunnableFuture<V>, ScheduledFuture<V> {
        boolean isPeriodic();
    }
    public interface Delayed extends Comparable<Delayed> {
        long getDelay(TimeUnit unit);
    }
    public interface ThreadFactory {
        Thread newThread(Runnable r);
    }
    public interface RejectedExecutionHandler {
        void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
    }
    ```
- 相关实现类
    ```java
    public class ThreadPoolExecutor extends AbstractExecutorService {
        // ctl:
        //      workerCount(29bit) indicating the effective number of threads
        //      runState(3bit)     indicating whether running, shutting down etc
        // runState
        //      RUNNING:    Accept new tasks and process queued tasks
        //      SHUTDOWN:   Don't accept new tasks, but process queued tasks
        //      STOP:       Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks
        //      TIDYING:    All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method
        //      TERMINATED: terminated() has completed
        //
        //      RUNNING                 ->      SHUTDOWN:   On invocation of shutdown()
        //      (RUNNING or SHUTDOWN)   ->      STOP:       On invocation of shutdownNow()
        //      SHUTDOWN                ->      TIDYING:    When both queue and pool are empty
        //      STOP                    ->      TIDYING:    When pool is empty
        //      TIDYING                 ->      TERMINATED: When the terminated() hook method has completed
        private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
        private static final int COUNT_BITS = Integer.SIZE - 3;
        private static final int COUNT_MASK = (1 << COUNT_BITS) - 1;
        // runState is stored in the high-order bits
        private static final int RUNNING    = -1 << COUNT_BITS;
        private static final int SHUTDOWN   =  0 << COUNT_BITS;
        private static final int STOP       =  1 << COUNT_BITS;
        private static final int TIDYING    =  2 << COUNT_BITS;
        private static final int TERMINATED =  3 << COUNT_BITS;
        // Packing and unpacking ctl
        private static int runStateOf(int c)     { return c & ~COUNT_MASK; }
        private static int workerCountOf(int c)  { return c & COUNT_MASK; }
        private static int ctlOf(int rs, int wc) { return rs | wc;
        // 任务队列
        private final BlockingQueue<Runnable> workQueue;
        // 线程池容器
        private final HashSet<Worker> workers = new HashSet<>();
        // 操作锁
        private final ReentrantLock mainLock = new ReentrantLock();
        private final Condition termination = mainLock.newCondition();

        private int largestPoolSize;
        private long completedTaskCount;

        private volatile ThreadFactory threadFactory;
        private volatile RejectedExecutionHandler handler;
        private volatile long keepAliveTime;
        private volatile boolean allowCoreThreadTimeOut;
        private volatile int corePoolSize;
        private volatile int maximumPoolSize;

        private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
        private static final RuntimePermission shutdownPerm = new RuntimePermission("modifyThread");
        // 添加任务
        public void execute(Runnable command) {
            if (command == null) throw new NullPointerException();
            /*
            * Proceed in 3 steps:
            * 1. 实际数小于限定数, 增加线程
            * 2. 加入任务队列
            * 3. 不能加入成功重新尝试增加线程
            */
            int c = ctl.get();
            if (workerCountOf(c) < corePoolSize) {
                if (addWorker(command, true))
                    return;
                c = ctl.get();
            }
            if (isRunning(c) && workQueue.offer(command)) {
                int recheck = ctl.get();
                if (! isRunning(recheck) && remove(command))
                    reject(command);
                else if (workerCountOf(recheck) == 0)
                    addWorker(null, false);
            }
            else if (!addWorker(command, false))
                reject(command);
        }
        private boolean addWorker(Runnable firstTask, boolean core) {
            // 增加内部worker计数
            retry:
            for (int c = ctl.get();;) {
                // 已关闭, 退出
                if (runStateAtLeast(c, SHUTDOWN)
                    && (runStateAtLeast(c, STOP)
                        || firstTask != null
                        || workQueue.isEmpty()))
                    return false;
                // 多次尝试
                for (;;) {
                    // 大于限定大小
                    if (workerCountOf(c)
                        >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))
                        return false;
                    // 增加成功
                    if (compareAndIncrementWorkerCount(c))
                        break retry;
                    c = ctl.get();  // Re-read ctl
                    if (runStateAtLeast(c, SHUTDOWN))
                        continue retry;
                }
            }
            boolean workerStarted = false;
            boolean workerAdded = false;
            Worker w = null;
            try {
                w = new Worker(firstTask);
                final Thread t = w.thread;
                if (t != null) {
                    final ReentrantLock mainLock = this.mainLock;
                    mainLock.lock();
                    try {
                        int c = ctl.get();
                        if (isRunning(c) ||
                            (runStateLessThan(c, STOP) && firstTask == null)) {
                            if (t.isAlive()) // precheck that t is startable
                                throw new IllegalThreadStateException();
                            workers.add(w);
                            int s = workers.size();
                            if (s > largestPoolSize)
                                largestPoolSize = s;
                            workerAdded = true;
                        }
                    } finally {
                        mainLock.unlock();
                    }
                    if (workerAdded) {
                        t.start();
                        workerStarted = true;
                    }
                }
            } finally {
                if (! workerStarted)
                    addWorkerFailed(w);
            }
            return workerStarted;
        }
        // worker主要执行逻辑
        final void runWorker(Worker w) {
            Thread wt = Thread.currentThread();
            Runnable task = w.firstTask;
            w.firstTask = null;
            w.unlock(); // allow interrupts
            boolean completedAbruptly = true;
            try {
                while (task != null || (task = getTask()) != null) {
                    w.lock();
                    // If pool is stopping, ensure thread is interrupted;
                    // if not, ensure thread is not interrupted.  This
                    // requires a recheck in second case to deal with
                    // shutdownNow race while clearing interrupt
                    if ((runStateAtLeast(ctl.get(), STOP) ||
                        (Thread.interrupted() &&
                        runStateAtLeast(ctl.get(), STOP))) &&
                        !wt.isInterrupted())
                        wt.interrupt();
                    try {
                        beforeExecute(wt, task);
                        try {
                            task.run();
                            afterExecute(task, null);
                        } catch (Throwable ex) {
                            afterExecute(task, ex);
                            throw ex;
                        }
                    } finally {
                        task = null;
                        w.completedTasks++;
                        w.unlock();
                    }
                }
                completedAbruptly = false;
            } finally {
                processWorkerExit(w, completedAbruptly);
            }
        }
        // 关闭
        public void shutdown() {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                checkShutdownAccess();
                advanceRunState(SHUTDOWN);
                interruptIdleWorkers();
                onShutdown(); // hook for ScheduledThreadPoolExecutor
            } finally {
                mainLock.unlock();
            }
            tryTerminate();
        }
        public List<Runnable> shutdownNow() {
            List<Runnable> tasks;
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                checkShutdownAccess();
                advanceRunState(STOP);
                interruptWorkers();
                tasks = drainQueue();
            } finally {
                mainLock.unlock();
            }
            tryTerminate();
            return tasks;
        }
        final void tryTerminate() {
            for (;;) {
                int c = ctl.get();
                if (isRunning(c) ||
                    runStateAtLeast(c, TIDYING) ||
                    (runStateLessThan(c, STOP) && ! workQueue.isEmpty()))
                    return;
                if (workerCountOf(c) != 0) { // Eligible to terminate
                    interruptIdleWorkers(ONLY_ONE);
                    return;
                }

                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                        try {
                            terminated();
                        } finally {
                            ctl.set(ctlOf(TERMINATED, 0));
                            termination.signalAll();
                        }
                        return;
                    }
                } finally {
                    mainLock.unlock();
                }
                // else retry on failed CAS
            }
        }
        private void interruptIdleWorkers(boolean onlyOne) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                for (Worker w : workers) {
                    Thread t = w.thread;
                    if (!t.isInterrupted() && w.tryLock()) {
                        try {
                            t.interrupt();
                        } catch (SecurityException ignore) {
                        } finally {
                            w.unlock();
                        }
                    }
                    if (onlyOne)
                        break;
                }
            } finally {
                mainLock.unlock();
            }
        }
        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
            long nanos = unit.toNanos(timeout);
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                while (runStateLessThan(ctl.get(), TERMINATED)) {
                    if (nanos <= 0L)
                        return false;
                    nanos = termination.awaitNanos(nanos);
                }
                return true;
            } finally {
                mainLock.unlock();
            }
        }
        // Lock methods
        //      The value 0 represents the unlocked state
        //      The value 1 represents the locked state
        private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
            final Thread thread;
            Runnable firstTask;
            volatile long completedTasks;
            Worker(Runnable firstTask) {
                setState(-1); // inhibit interrupts until runWorker
                this.firstTask = firstTask;
                this.thread = getThreadFactory().newThread(this);
            }
            public void run() {
                runWorker(this);
            }
            protected boolean isHeldExclusively() {
                return getState() != 0;
            }
            protected boolean tryAcquire(int unused) {
                if (compareAndSetState(0, 1)) {
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                }
                return false;
            }
            protected boolean tryRelease(int unused) {
                setExclusiveOwnerThread(null);
                setState(0);
                return true;
            }
        }
        /*
         * 拒绝任务策略
         */
        // 调用者完成
        public static class CallerRunsPolicy implements RejectedExecutionHandler {
            public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                if (!e.isShutdown()) {
                    r.run();
                }
            }
        }
        // 直接拒绝抛异常
        public static class AbortPolicy implements RejectedExecutionHandler {
            public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString());
            }
        }
        // 直接抛弃
        public static class DiscardPolicy implements RejectedExecutionHandler {
            public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            }
        }
        // 丢弃最老的
        public static class DiscardOldestPolicy implements RejectedExecutionHandler {
            public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                if (!e.isShutdown()) {
                    e.getQueue().poll();
                    e.execute(r);
                }
            }
        }
    }
    public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService {
        // False if should cancel/suppress periodic tasks on shutdown
        private volatile boolean continueExistingPeriodicTasksAfterShutdown;
        // False if should cancel non-periodic not-yet-expired tasks on shutdown
        private volatile boolean executeExistingDelayedTasksAfterShutdown = true;
        // True if ScheduledFutureTask.cancel should remove from queue
        volatile boolean removeOnCancel;
        // Sequence number to break scheduling ties, and in turn to guarantee FIFO order among tied entries
        private static final AtomicLong sequencer = new AtomicLong();

        private class ScheduledFutureTask<V> extends FutureTask<V> implements RunnableScheduledFuture<V> {
            // Sequence number to break ties FIFO
            private final long sequenceNumber;
            // The nanoTime-based time when the task is enabled to execute
            private volatile long time;
            /**
            * Period for repeating tasks, in nanoseconds.
            * A positive value indicates fixed-rate execution.
            * A negative value indicates fixed-delay execution.
            * A value of 0 indicates a non-repeating (one-shot) task.
            */
            private final long period;
            // The actual task to be re-enqueued by reExecutePeriodic
            RunnableScheduledFuture<V> outerTask = this;
            // Index into delay queue, to support faster cancellation
            int heapIndex;

            private void setNextRunTime() {
                long p = period;
                if (p > 0) time += p;
                else time = triggerTime(-p);
            }
            public boolean cancel(boolean mayInterruptIfRunning) {
                // The racy read of heapIndex below is benign:
                // if heapIndex < 0, then OOTA guarantees that we have surely
                // been removed; else we recheck under lock in remove()
                boolean cancelled = super.cancel(mayInterruptIfRunning);
                if (cancelled && removeOnCancel && heapIndex >= 0) remove(this);
                return cancelled;
            }
            public void run() {
                if (!canRunInCurrentRunState(this)) cancel(false);
                else if (!isPeriodic()) super.run();
                else if (super.runAndReset()) {
                    setNextRunTime();
                    reExecutePeriodic(outerTask);
                }
            }
        }
        boolean canRunInCurrentRunState(RunnableScheduledFuture<?> task) {
            if (!isShutdown()) return true;
            if (isStopped()) return false;
            return task.isPeriodic()
                ? continueExistingPeriodicTasksAfterShutdown
                : (executeExistingDelayedTasksAfterShutdown
                || task.getDelay(NANOSECONDS) <= 0);
        }
        private void delayedExecute(RunnableScheduledFuture<?> task) {
            if (isShutdown()) reject(task);
            else {
                super.getQueue().add(task);
                if (!canRunInCurrentRunState(task) && remove(task)) task.cancel(false);
                else ensurePrestart();
            }
        }
        void reExecutePeriodic(RunnableScheduledFuture<?> task) {
            if (canRunInCurrentRunState(task)) {
                super.getQueue().add(task);
                if (canRunInCurrentRunState(task) || !remove(task)) {
                    ensurePrestart();
                    return;
                }
            }
            task.cancel(false);
        }
        @Override void onShutdown() {
            BlockingQueue<Runnable> q = super.getQueue();
            boolean keepDelayed =
                getExecuteExistingDelayedTasksAfterShutdownPolicy();
            boolean keepPeriodic =
                getContinueExistingPeriodicTasksAfterShutdownPolicy();
            // Traverse snapshot to avoid iterator exceptions
            // TODO: implement and use efficient removeIf
            // super.getQueue().removeIf(...);
            for (Object e : q.toArray()) {
                if (e instanceof RunnableScheduledFuture) {
                    RunnableScheduledFuture<?> t = (RunnableScheduledFuture<?>)e;
                    if ((t.isPeriodic()
                        ? !keepPeriodic
                        : (!keepDelayed && t.getDelay(NANOSECONDS) > 0))
                        || t.isCancelled()) { // also remove if already cancelled
                        if (q.remove(t))
                            t.cancel(false);
                    }
                }
            }
            tryTerminate();
        }
        // Returns the nanoTime-based trigger time of a delayed action
        private long triggerTime(long delay, TimeUnit unit) {
            return triggerTime(unit.toNanos((delay < 0) ? 0 : delay));
        }
        long triggerTime(long delay) {
            return System.nanoTime() + ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));
        }
        public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
            if (command == null || unit == null) throw new NullPointerException();
            RunnableScheduledFuture<Void> t = decorateTask(command,
                new ScheduledFutureTask<Void>(command, null, triggerTime(delay, unit), sequencer.getAndIncrement()));
            delayedExecute(t);
            return t;
        }
        public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
            if (callable == null || unit == null) throw new NullPointerException();
            RunnableScheduledFuture<V> t = decorateTask(callable, new ScheduledFutureTask<V>(callable, triggerTime(delay, unit), sequencer.getAndIncrement()));
            delayedExecute(t);
            return t;
        }
        public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
            if (command == null || unit == null) throw new NullPointerException();
            if (period <= 0L) throw new IllegalArgumentException();
            ScheduledFutureTask<Void> sft = new ScheduledFutureTask<Void>(command, null, triggerTime(initialDelay, unit), unit.toNanos(period), sequencer.getAndIncrement());
            RunnableScheduledFuture<Void> t = decorateTask(command, sft);
            sft.outerTask = t;
            delayedExecute(t);
            return t;
        }
        public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
            if (command == null || unit == null) throw new NullPointerException();
            if (delay <= 0L) throw new IllegalArgumentException();
            ScheduledFutureTask<Void> sft = new ScheduledFutureTask<Void>(command, null, triggerTime(initialDelay, unit), -unit.toNanos(delay), sequencer.getAndIncrement());
            RunnableScheduledFuture<Void> t = decorateTask(command, sft);
            sft.outerTask = t;
            delayedExecute(t);
            return t;
        }
        // DelayedWorkQueue 实现延迟的效果
        static class DelayedWorkQueue extends AbstractQueue<Runnable> implements BlockingQueue<Runnable> {
            private static final int INITIAL_CAPACITY = 16;
            private RunnableScheduledFuture<?>[] queue = new RunnableScheduledFuture<?>[INITIAL_CAPACITY];
            private final ReentrantLock lock = new ReentrantLock();
            private int size;
            private Thread leader;
            private final Condition available = lock.newCondition();
            private static void setIndex(RunnableScheduledFuture<?> f, int idx) {
                if (f instanceof ScheduledFutureTask)
                    ((ScheduledFutureTask)f).heapIndex = idx;
            }
            private void siftUp(int k, RunnableScheduledFuture<?> key) {
                while (k > 0) {
                    int parent = (k - 1) >>> 1;
                    RunnableScheduledFuture<?> e = queue[parent];
                    if (key.compareTo(e) >= 0)
                        break;
                    queue[k] = e;
                    setIndex(e, k);
                    k = parent;
                }
                queue[k] = key;
                setIndex(key, k);
            }
            private void siftDown(int k, RunnableScheduledFuture<?> key) {
                int half = size >>> 1;
                while (k < half) {
                    int child = (k << 1) + 1;
                    RunnableScheduledFuture<?> c = queue[child];
                    int right = child + 1;
                    if (right < size && c.compareTo(queue[right]) > 0)
                        c = queue[child = right];
                    if (key.compareTo(c) <= 0)
                        break;
                    queue[k] = c;
                    setIndex(c, k);
                    k = child;
                }
                queue[k] = key;
                setIndex(key, k);
            }
            private void grow() {
                int oldCapacity = queue.length;
                int newCapacity = oldCapacity + (oldCapacity >> 1); // grow 50%
                if (newCapacity < 0) // overflow
                    newCapacity = Integer.MAX_VALUE;
                queue = Arrays.copyOf(queue, newCapacity);
            }
            private int indexOf(Object x) {
                if (x != null) {
                    if (x instanceof ScheduledFutureTask) {
                        int i = ((ScheduledFutureTask) x).heapIndex;
                        // Sanity check; x could conceivably be a
                        // ScheduledFutureTask from some other pool.
                        if (i >= 0 && i < size && queue[i] == x)
                            return i;
                    } else {
                        for (int i = 0; i < size; i++)
                            if (x.equals(queue[i]))
                                return i;
                    }
                }
                return -1;
            }
            public boolean contains(Object x) {
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    return indexOf(x) != -1;
                } finally {
                    lock.unlock();
                }
            }
            public boolean remove(Object x) {
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    int i = indexOf(x);
                    if (i < 0)
                        return false;

                    setIndex(queue[i], -1);
                    int s = --size;
                    RunnableScheduledFuture<?> replacement = queue[s];
                    queue[s] = null;
                    if (s != i) {
                        siftDown(i, replacement);
                        if (queue[i] == replacement)
                            siftUp(i, replacement);
                    }
                    return true;
                } finally {
                    lock.unlock();
                }
            }
            public int size() {
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    return size;
                } finally {
                    lock.unlock();
                }
            }
            public boolean isEmpty() {
                return size() == 0;
            }
            public int remainingCapacity() {
                return Integer.MAX_VALUE;
            }
            public RunnableScheduledFuture<?> peek() {
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    return queue[0];
                } finally {
                    lock.unlock();
                }
            }
            public boolean offer(Runnable x) {
                if (x == null)
                    throw new NullPointerException();
                RunnableScheduledFuture<?> e = (RunnableScheduledFuture<?>)x;
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    int i = size;
                    if (i >= queue.length)
                        grow();
                    size = i + 1;
                    if (i == 0) {
                        queue[0] = e;
                        setIndex(e, 0);
                    } else {
                        siftUp(i, e);
                    }
                    if (queue[0] == e) {
                        leader = null;
                        available.signal();
                    }
                } finally {
                    lock.unlock();
                }
                return true;
            }
            public void put(Runnable e) {
                offer(e);
            }
            public boolean add(Runnable e) {
                return offer(e);
            }
            public boolean offer(Runnable e, long timeout, TimeUnit unit) {
                return offer(e);
            }
            private RunnableScheduledFuture<?> finishPoll(RunnableScheduledFuture<?> f) {
                int s = --size;
                RunnableScheduledFuture<?> x = queue[s];
                queue[s] = null;
                if (s != 0)
                    siftDown(0, x);
                setIndex(f, -1);
                return f;
            }
            public RunnableScheduledFuture<?> poll() {
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    RunnableScheduledFuture<?> first = queue[0];
                    return (first == null || first.getDelay(NANOSECONDS) > 0)
                        ? null
                        : finishPoll(first);
                } finally {
                    lock.unlock();
                }
            }
            public RunnableScheduledFuture<?> take() throws InterruptedException {
                final ReentrantLock lock = this.lock;
                lock.lockInterruptibly();
                try {
                    for (;;) {
                        RunnableScheduledFuture<?> first = queue[0];
                        if (first == null)
                            available.await();
                        else {
                            long delay = first.getDelay(NANOSECONDS);
                            if (delay <= 0L)
                                return finishPoll(first);
                            first = null; // don't retain ref while waiting
                            if (leader != null)
                                available.await();
                            else {
                                Thread thisThread = Thread.currentThread();
                                leader = thisThread;
                                try {
                                    available.awaitNanos(delay);
                                } finally {
                                    if (leader == thisThread)
                                        leader = null;
                                }
                            }
                        }
                    }
                } finally {
                    if (leader == null && queue[0] != null)
                        available.signal();
                    lock.unlock();
                }
            }
            public RunnableScheduledFuture<?> poll(long timeout, TimeUnit unit)
                throws InterruptedException {
                long nanos = unit.toNanos(timeout);
                final ReentrantLock lock = this.lock;
                lock.lockInterruptibly();
                try {
                    for (;;) {
                        RunnableScheduledFuture<?> first = queue[0];
                        if (first == null) {
                            if (nanos <= 0L)
                                return null;
                            else
                                nanos = available.awaitNanos(nanos);
                        } else {
                            long delay = first.getDelay(NANOSECONDS);
                            if (delay <= 0L)
                                return finishPoll(first);
                            if (nanos <= 0L)
                                return null;
                            first = null; // don't retain ref while waiting
                            if (nanos < delay || leader != null)
                                nanos = available.awaitNanos(nanos);
                            else {
                                Thread thisThread = Thread.currentThread();
                                leader = thisThread;
                                try {
                                    long timeLeft = available.awaitNanos(delay);
                                    nanos -= delay - timeLeft;
                                } finally {
                                    if (leader == thisThread)
                                        leader = null;
                                }
                            }
                        }
                    }
                } finally {
                    if (leader == null && queue[0] != null)
                        available.signal();
                    lock.unlock();
                }
            }
            public void clear() {
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    for (int i = 0; i < size; i++) {
                        RunnableScheduledFuture<?> t = queue[i];
                        if (t != null) {
                            queue[i] = null;
                            setIndex(t, -1);
                        }
                    }
                    size = 0;
                } finally {
                    lock.unlock();
                }
            }
            public int drainTo(Collection<? super Runnable> c) {
                return drainTo(c, Integer.MAX_VALUE);
            }
            public int drainTo(Collection<? super Runnable> c, int maxElements) {
                Objects.requireNonNull(c);
                if (c == this)
                    throw new IllegalArgumentException();
                if (maxElements <= 0)
                    return 0;
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    int n = 0;
                    for (RunnableScheduledFuture<?> first;
                        n < maxElements
                            && (first = queue[0]) != null
                            && first.getDelay(NANOSECONDS) <= 0;) {
                        c.add(first);   // In this order, in case add() throws.
                        finishPoll(first);
                        ++n;
                    }
                    return n;
                } finally {
                    lock.unlock();
                }
            }
            public Object[] toArray() {
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    return Arrays.copyOf(queue, size, Object[].class);
                } finally {
                    lock.unlock();
                }
            }
            public <T> T[] toArray(T[] a) {
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    if (a.length < size)
                        return (T[]) Arrays.copyOf(queue, size, a.getClass());
                    System.arraycopy(queue, 0, a, 0, size);
                    if (a.length > size)
                        a[size] = null;
                    return a;
                } finally {
                    lock.unlock();
                }
            }
            public Iterator<Runnable> iterator() {
                final ReentrantLock lock = this.lock;
                lock.lock();
                try {
                    return new Itr(Arrays.copyOf(queue, size));
                } finally {
                    lock.unlock();
                }
            }
            private class Itr implements Iterator<Runnable> {
                final RunnableScheduledFuture<?>[] array;
                int cursor;        // index of next element to return; initially 0
                int lastRet = -1;  // index of last element returned; -1 if no such

                Itr(RunnableScheduledFuture<?>[] array) {
                    this.array = array;
                }

                public boolean hasNext() {
                    return cursor < array.length;
                }

                public Runnable next() {
                    if (cursor >= array.length)
                        throw new NoSuchElementException();
                    return array[lastRet = cursor++];
                }
                public void remove() {
                    if (lastRet < 0)
                        throw new IllegalStateException();
                    DelayedWorkQueue.this.remove(array[lastRet]);
                    lastRet = -1;
                }
            }
        }
    }
    public class FutureTask<V> implements RunnableFuture<V> {
        /**
        * Possible state transitions:
        *   NEW -> COMPLETING -> NORMAL
        *   NEW -> COMPLETING -> EXCEPTIONAL
        *   NEW -> CANCELLED
        *   NEW -> INTERRUPTING -> INTERRUPTED
        */
        private volatile int state;
        private static final int NEW          = 0;
        private static final int COMPLETING   = 1;
        private static final int NORMAL       = 2;
        private static final int EXCEPTIONAL  = 3;
        private static final int CANCELLED    = 4;
        private static final int INTERRUPTING = 5;
        private static final int INTERRUPTED  = 6;
        /** The underlying callable; nulled out after running */
        private Callable<V> callable;
        /** The result to return or exception to throw from get() */
        private Object outcome; // non-volatile, protected by state reads/writes
        /** The thread running the callable; CASed during run() */
        private volatile Thread runner;
        /** Treiber stack of waiting threads */
        private volatile WaitNode waiters;
        // VarHandle mechanics
        private static final VarHandle STATE;
        private static final VarHandle RUNNER;
        private static final VarHandle WAITERS;
        static {
            try {
                MethodHandles.Lookup l = MethodHandles.lookup();
                STATE = l.findVarHandle(FutureTask.class, "state", int.class);
                RUNNER = l.findVarHandle(FutureTask.class, "runner", Thread.class);
                WAITERS = l.findVarHandle(FutureTask.class, "waiters", WaitNode.class);
            } catch (ReflectiveOperationException e) {
                throw new ExceptionInInitializerError(e);
            }
            // Reduce the risk of rare disastrous classloading in first call to
            // LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773
            Class<?> ensureLoaded = LockSupport.class;
        }
        public boolean cancel(boolean mayInterruptIfRunning) {
            if (!(state == NEW && STATE.compareAndSet
                (this, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false;
            try {    // in case call to interrupt throws exception
                if (mayInterruptIfRunning) {
                    try {
                        Thread t = runner;
                        if (t != null) t.interrupt();
                    } finally { // final state
                        STATE.setRelease(this, INTERRUPTED);
                    }
                }
            } finally {
                finishCompletion();
            }
            return true;
        }
        protected void set(V v) {
            if (STATE.compareAndSet(this, NEW, COMPLETING)) {
                outcome = v;
                STATE.setRelease(this, NORMAL); // final state
                finishCompletion();
            }
        }
        protected void setException(Throwable t) {
            if (STATE.compareAndSet(this, NEW, COMPLETING)) {
                outcome = t;
                STATE.setRelease(this, EXCEPTIONAL); // final state
                finishCompletion();
            }
        }
        public void run() {
            if (state != NEW ||
                !RUNNER.compareAndSet(this, null, Thread.currentThread())) return;
            try {
                Callable<V> c = callable;
                if (c != null && state == NEW) {
                    V result;
                    boolean ran;
                    try {
                        result = c.call();
                        ran = true;
                    } catch (Throwable ex) {
                        result = null;
                        ran = false;
                        setException(ex);
                    }
                    if (ran) set(result);
                }
            } finally {
                // runner must be non-null until state is settled to
                // prevent concurrent calls to run()
                runner = null;
                // state must be re-read after nulling runner to prevent
                // leaked interrupts
                int s = state;
                if (s >= INTERRUPTING)
                    handlePossibleCancellationInterrupt(s);
            }
        }
        protected boolean runAndReset() {
            if (state != NEW ||
                !RUNNER.compareAndSet(this, null, Thread.currentThread()))
                return false;
            boolean ran = false;
            int s = state;
            try {
                Callable<V> c = callable;
                if (c != null && s == NEW) {
                    try {
                        c.call(); // don't set result
                        ran = true;
                    } catch (Throwable ex) {
                        setException(ex);
                    }
                }
            } finally {
                // runner must be non-null until state is settled to
                // prevent concurrent calls to run()
                runner = null;
                // state must be re-read after nulling runner to prevent
                // leaked interrupts
                s = state;
                if (s >= INTERRUPTING)
                    handlePossibleCancellationInterrupt(s);
            }
            return ran && s == NEW;
        }
        private void handlePossibleCancellationInterrupt(int s) {
            // It is possible for our interrupter to stall before getting a
            // chance to interrupt us.  Let's spin-wait patiently.
            if (s == INTERRUPTING)
                while (state == INTERRUPTING)
                    Thread.yield(); // wait out pending interrupt

            // assert state == INTERRUPTED;

            // We want to clear any interrupt we may have received from
            // cancel(true).  However, it is permissible to use interrupts
            // as an independent mechanism for a task to communicate with
            // its caller, and there is no way to clear only the
            // cancellation interrupt.
            //
            // Thread.interrupted();
        }
        static final class WaitNode {
            volatile Thread thread;
            volatile WaitNode next;
            WaitNode() { thread = Thread.currentThread(); }
        }
        private void finishCompletion() {
            // assert state > COMPLETING;
            for (WaitNode q; (q = waiters) != null;) {
                if (WAITERS.weakCompareAndSet(this, q, null)) {
                    for (;;) {
                        Thread t = q.thread;
                        if (t != null) {
                            q.thread = null;
                            LockSupport.unpark(t);
                        }
                        WaitNode next = q.next;
                        if (next == null)
                            break;
                        q.next = null; // unlink to help gc
                        q = next;
                    }
                    break;
                }
            }
            done();
            callable = null;        // to reduce footprint
        }
        private int awaitDone(boolean timed, long nanos)
            throws InterruptedException {
            // The code below is very delicate, to achieve these goals:
            // - call nanoTime exactly once for each call to park
            // - if nanos <= 0L, return promptly without allocation or nanoTime
            // - if nanos == Long.MIN_VALUE, don't underflow
            // - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic
            //   and we suffer a spurious wakeup, we will do no worse than
            //   to park-spin for a while
            long startTime = 0L;    // Special value 0L means not yet parked
            WaitNode q = null;
            boolean queued = false;
            for (;;) {
                int s = state;
                if (s > COMPLETING) {
                    if (q != null) q.thread = null;
                    return s;
                }
                else if (s == COMPLETING)
                    // We may have already promised (via isDone) that we are done
                    // so never return empty-handed or throw InterruptedException
                    Thread.yield();
                else if (Thread.interrupted()) {
                    removeWaiter(q);
                    throw new InterruptedException();
                }
                else if (q == null) {
                    if (timed && nanos <= 0L) return s;
                    q = new WaitNode();
                }
                else if (!queued) queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);
                else if (timed) {
                    final long parkNanos;
                    if (startTime == 0L) { // first time
                        startTime = System.nanoTime();
                        if (startTime == 0L)
                            startTime = 1L;
                        parkNanos = nanos;
                    } else {
                        long elapsed = System.nanoTime() - startTime;
                        if (elapsed >= nanos) {
                            removeWaiter(q);
                            return state;
                        }
                        parkNanos = nanos - elapsed;
                    }
                    // nanoTime may be slow; recheck before parking
                    if (state < COMPLETING) LockSupport.parkNanos(this, parkNanos);
                }
                else LockSupport.park(this);
            }
        }
        private void removeWaiter(WaitNode node) {
            if (node != null) {
                node.thread = null;
                retry:
                for (;;) {          // restart on removeWaiter race
                    for (WaitNode pred = null, q = waiters, s; q != null; q = s) {
                        s = q.next;
                        if (q.thread != null)
                            pred = q;
                        else if (pred != null) {
                            pred.next = s;
                            if (pred.thread == null) // check for race
                                continue retry;
                        }
                        else if (!WAITERS.compareAndSet(this, q, s))
                            continue retry;
                    }
                    break;
                }
            }
        }
        public String toString() {
            final String status;
            switch (state) {
            case NORMAL:
                status = "[Completed normally]";
                break;
            case EXCEPTIONAL:
                status = "[Completed exceptionally: " + outcome + "]";
                break;
            case CANCELLED:
            case INTERRUPTING:
            case INTERRUPTED:
                status = "[Cancelled]";
                break;
            default:
                final Callable<?> callable = this.callable;
                status = (callable == null)
                    ? "[Not completed]"
                    : "[Not completed, task = " + callable + "]";
            }
            return super.toString() + status;
        }
    }
    ```
- 工具类实现
    ```java
    public class Executors {
        //  A callable that runs given task and returns given result
        private static final class RunnableAdapter<T> implements Callable<T> {
            private final Runnable task;
            private final T result;
            RunnableAdapter(Runnable task, T result) {
                this.task = task;
                this.result = result;
            }
            public T call() {
                task.run();
                return result;
            }
            public String toString() {
                return super.toString() + "[Wrapped task = " + task + "]";
            }
        }
        // A callable that runs under established access control settings
        private static final class PrivilegedCallable<T> implements Callable<T> {
            final Callable<T> task;
            final AccessControlContext acc;
            PrivilegedCallable(Callable<T> task) {
                this.task = task;
                this.acc = AccessController.getContext();
            }
            public T call() throws Exception {
                try {
                    return AccessController.doPrivileged(
                        new PrivilegedExceptionAction<T>() {
                            public T run() throws Exception {
                                return task.call();
                            }
                        }, acc);
                } catch (PrivilegedActionException e) {
                    throw e.getException();
                }
            }
            public String toString() {
                return super.toString() + "[Wrapped task = " + task + "]";
            }
        }
        // A callable that runs under established access control settings and current ClassLoader
        private static final class PrivilegedCallableUsingCurrentClassLoader<T>
                implements Callable<T> {
            final Callable<T> task;
            final AccessControlContext acc;
            final ClassLoader ccl;
            PrivilegedCallableUsingCurrentClassLoader(Callable<T> task) {
                SecurityManager sm = System.getSecurityManager();
                if (sm != null) {
                    // Calls to getContextClassLoader from this class
                    // never trigger a security check, but we check
                    // whether our callers have this permission anyways.
                    sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);

                    // Whether setContextClassLoader turns out to be necessary
                    // or not, we fail fast if permission is not available.
                    sm.checkPermission(new RuntimePermission("setContextClassLoader"));
                }
                this.task = task;
                this.acc = AccessController.getContext();
                this.ccl = Thread.currentThread().getContextClassLoader();
            }
            public T call() throws Exception {
                try {
                    return AccessController.doPrivileged(
                        new PrivilegedExceptionAction<T>() {
                            public T run() throws Exception {
                                Thread t = Thread.currentThread();
                                ClassLoader cl = t.getContextClassLoader();
                                if (ccl == cl) {
                                    return task.call();
                                } else {
                                    t.setContextClassLoader(ccl);
                                    try {
                                        return task.call();
                                    } finally {
                                        t.setContextClassLoader(cl);
                                    }
                                }
                            }
                        }, acc);
                } catch (PrivilegedActionException e) {
                    throw e.getException();
                }
            }
            public String toString() {
                return super.toString() + "[Wrapped task = " + task + "]";
            }
        }
        // The default thread factory
        private static class DefaultThreadFactory implements ThreadFactory {
            private static final AtomicInteger poolNumber = new AtomicInteger(1);
            private final ThreadGroup group;
            private final AtomicInteger threadNumber = new AtomicInteger(1);
            private final String namePrefix;
            DefaultThreadFactory() {
                SecurityManager s = System.getSecurityManager();
                group = (s != null) ? s.getThreadGroup() :
                                    Thread.currentThread().getThreadGroup();
                namePrefix = "pool-" +
                            poolNumber.getAndIncrement() +
                            "-thread-";
            }
            public Thread newThread(Runnable r) {
                Thread t = new Thread(group, r,
                                    namePrefix + threadNumber.getAndIncrement(),
                                    0);
                if (t.isDaemon())
                    t.setDaemon(false);
                if (t.getPriority() != Thread.NORM_PRIORITY)
                    t.setPriority(Thread.NORM_PRIORITY);
                return t;
            }
        }
    }
    ```