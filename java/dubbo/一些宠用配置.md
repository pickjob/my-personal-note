# dubbo一些常用配置
- Check on start up
    ```xml
    <dubbo:reference interface = "com.foo.BarService" check = "false" />
    <dubbo:consumer check = "false" />
    <dubbo:registry check="false" />
    ```
- Fault Tolerance Strategy
    ```xml
    <dubbo:service retries="2" />
    <dubbo:reference retries="2" />
    <dubbo:reference>
        <dubbo:method name="findFoo" retries="2" />
    </dubbo:reference>
    <!-- failfast failsafe failback forking broadcast -->
    <dubbo:service cluster="failsafe" />
    ```
- LoadBalance
    ```xml
    <!-- random roundrobin leastactive consistenthash -->
    <dubbo:service interface="..." loadbalance="roundrobin" />
    <dubbo:service interface="...">
        <dubbo:method name="..." loadbalance="roundrobin"/>
    </dubbo:service>
    <dubbo:reference interface="..." loadbalance="roundrobin" />
    <dubbo:reference interface="...">
        <dubbo:method name="..." loadbalance="roundrobin"/>
    </dubbo:reference>
    ```
- Thread Model
    ```xml
    <!-- all direct message execution connection -->
    <!-- fixed cached limit -->
    <dubbo:protocol name="dubbo" dispatcher="all" threadpool="fixed" threads="100" />
    ```
- Cache Result
    ```xml
    <!-- lru threadlocal jcache -->
    <dubbo:reference interface="com.foo.BarService" cache="lru" />
    ```
- Asynchronous Call
    ```xml
    <dubbo:reference id="fooService" interface="com.alibaba.foo.FooService">
        <dubbo:method name="findFoo" async="true" sent="true" return="false" />
    </dubbo:reference>
    <dubbo:reference id="barService" interface="com.alibaba.bar.BarService">
        <dubbo:method name="findBar" async="true" />
    </dubbo:reference>
    ```
    ```java
    // the invoke will return null immediately
    fooService.findFoo(fooId);
    // get current invoke Future instance,when the remote service has return result,will notify this Future instance.
    Future<Foo> fooFuture = RpcContext.getContext().getFuture();
    // the invoke will return null immediately
    barService.findBar(barId);
    // get current invoke Future instance,when the remote service has return result,will notify this Future instance.
    Future<Bar> barFuture = RpcContext.getContext().getFuture();
    // now the request of findFoo and findBar was executed at same time,The client not need setup multithreading for parallel call, which is NIO-based non-blocking implementation of parallel calls
    // Current thread will be blocking,and wait findFoo has return. when remote service has return findFoo result,the current thread will be wake up.
    Foo foo = fooFuture.get();
    // same to findFoo
    Bar bar = barFuture.get();
    // if findFoo expend five second for wait remote service  return result,and findBar expend six second. Actually,only expend six second will get findFoo and findBar result,and proceed to the next step.
    ```
- Callback parameter
    ```xml
    <bean id="callbackService" class="com.callback.impl.CallbackServiceImpl" />
    <dubbo:service interface="com.callback.CallbackService" ref="callbackService" connections="1" callbacks="1000">
        <dubbo:method name="addListener">
            <dubbo:argument index="1" callback="true" />
            <!--also can via specified argument type-->
            <!--<dubbo:argument type="com.demo.CallbackListener" callback="true" />-->
        </dubbo:method>
    </dubbo:service>
    ```
- Event Notify
    ```xml
    <bean id ="demoCallback" class = "com.alibaba.dubbo.callback.implicit.NofifyImpl" />
    <dubbo:reference id="demoService" interface="com.alibaba.dubbo.callback.implicit.IDemoService" version="1.0.0" group="cn" >
        <dubbo:method name="get" async="true" onreturn = "demoCallback.onreturn" onthrow="demoCallback.onthrow" />
    </dubbo:reference>
    ```
- Local mock
    ```xml
    <dubbo:reference interface="com.foo.BarService" mock="true" />
    <dubbo:reference interface="com.foo.BarService" mock="com.foo.BarServiceMock" />
    ```
- 