# 程序设计实践
- 风格
    - 全局变量使用具有说明性名字, 局部变量使用短名字
    - 给非0和1的数(神秘数)起个的名字
    - 函数采用动作性名字
    - 缩进形式显示程序结构
- 设计模式
    - 创建(Creational)
        - Factory Method: 定义一个用于创建对象的接口, 让子类决定哪一个类实例化
        - Abstract Factory: 提供一个创建一系列相关或相互依赖对象的接口,无需指定具体类
        - Builder: 一个复杂对象的构建与他的表示分离
        - Prototype: 原型实力指定创建对象种类
        - Singleton: 一个类仅有一个实例
    - 结构(Structural)
        - Adapter: 将一个类的接口转换成客户希望的另一个接口
        - Bridge: 抽象和实现分离
        - Composite: 对象组合成树形结构
        - Decorator: 动态的给一个对象添加一些额外的职责
        - Facade: 为子系统中一组接口提供一直的界面
        - Flyweight:
        - Proxy: 其他对象提供一种代理以控制对这个对象的访问
    - 行为(Behavioral)
        - Interpreter:
        - Template Method:
        - Chain of Responsibility: 接触请求发送者和接收者之间的耦合,多个对象都有机会处理,职责分离
        - Command: 一个请求封装成一个对象,
        - Interator: 提供一种顺序访问一个聚合对象的方法
        - Mediator: 用一个中介对象封装一系列的对象操作
        - Memento: 在不破坏封装性的前提下, 捕获一个对象的内部状态
        - Observer: 定义对象间的一种一对多的以来关系
        - State: 允许一个对象内部状态改变时改变他的行为
        - Strategy: 定义一系列算法,封装起来,相互替换
        - Visitor:
- SOLID (面向对象设计)
    - 单一功能原则(Single responsibility principle, SRP): 修改一个类的原因应该只有一个
    - 开闭原则(Open–closed principle, OCP): 类应该对扩展开放，对修改关闭
    - 里氏替换原则(Liskov Substitution principle, LSP): 子类对象必须能够替换掉所有父类对象
    - 接口隔离原则(interface-segregation principles): 客户(client)不应被迫使用对其而言无用的方法或功能
    - 依赖反转原则(Dependency inversion principle, DIP)
        - 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口
        - 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口
    - 迪米特法则(Law of Demeter or Least Knowlegde Principle , LOD / LKP): 一个对象应当对其他对象有尽可能少的了解，不和陌生人说话
    - 合成复用原则(The Composite Reuse Principle, CRP): 尽量使用对象组合，而不是通过继承来达到复用的目的
    - 共同封闭原则(The Common Closure Principle, CCP): 一起修改的类，应该组合在一起(同一个包里)
    - 稳定抽象原则(The Stable Abstractions Principle, SAP): 包的抽象程度跟它的稳定性成正比
    - 稳定依赖原则(The Stable Dependencies Principle, SDP): 包要依赖的包要比自己更具有稳定性 
- 其他一些原则
    - Don't repeat yourself.(DRY)
    - Keep It Simple, Stupid.(KISS)
    - convention over configuration.(约定优于配置)
    - Inversion of Control.(IoC, 依赖反转, 依赖注入Dependency Injection)