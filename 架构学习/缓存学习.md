# 缓存学习
- 缓存算法
    - LRU(Least-Recently-Used)
    - LFU(Least-Frequently-Used)
    - LRU2(Least Recently Used 2)
    - 2Q(Two Queues)
    - SIZE
    - LRU-Threshold
    - Log(Size)+LRU
    - Hyper-G
    - Pitkow/Recker
    - Lowest-Latency-First
    - Hybrid Hybrid
    - LRV(Lowest Relative Value)
    - ARC(Adaptive Replacement Cache)
    - MRU(Most Recently Used)
    - FIFO(First in First out)
    - Random Cache
- Cache API
    - CachingProvider
    - CacheManager
    - Cache
    - Entry
- annotatin
    - @Cacheable
    - @CachePut
    - @CachEvict
    - @CacheConfig
- Ehcache
- guava
- memcached
- aerospike
- 缓存使用方式
    - Cache-Aside
    - Cache-As-SoR
    - Read-Through
    - Refresh-Ahead
    - Write-Through
    - Write-Behind
- 缓存协议
    - 文本西医
    - 二进制
- 缓存分类
    - 按位置
        - 客户端缓存
            - 页面缓存
            - 浏览器缓存
            - APP缓存
        - 服务端缓存
            - 数据库缓存
            - 平台级缓存
            - 应用级缓存
        - 网络中缓存
            - Web缓存代理
            - 边缘缓存
    - 规模
        - 单体缓存
        - 缓存集群
        - 分布式缓存
- 模式
    - 双读写
        - 读: 先读缓存再数据库再回写缓存
        - 写: 先写数据库再写缓存
    - 异步更新
        - 只读写缓存
    - 串联
        - 缓存读写
- 缓存读写模式、更新策略
    - Cache Aside Pattern(旁路缓存模式)
        - 写: 更新DB, 然后删除cache
        - 读: 从cache中读取数据, 读到数据直接返回, 读不到数据, 从DB中取数据, 然后放入cahce中
    - Read/Write Through patter(读写穿透)
        - 写: 先查cache, 不存在直接更新DB, 存在先更新cache, 然后cache服务更新DB
        - 读: 从cache中读取数据, 读到数据直接返回, 读不到数据, 从DB中取数据, 然后放入cahce中
    - Write Behind Pattern(异步缓存写入)
        - 异步批量的方式来更新 DB
- 缓存分片
    - 客户端分片
    - 代理分片
    - 集群分片
- 迁移方案
    - 平滑迁移
        - 双写
        - 迁移历史数据
        - 切读
        - 下双写
    - 停机迁移
        - 停机应用
        - 迁移历史数据
        - 更改应用的数据源配置
        - 重新启动应用
    - 一致性哈希
- 问题
    - 缓存穿透: 用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题
    - 缓存并发
        - 分布式锁
        - 本地锁
        - 软过期
    - 缓存雪崩: 由于原有缓存失效、新缓存未到之间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机
- 优秀实践
    - 内存大小预先评估
    - 缓存业务分离, 互不影响
    - 缓存实例数量
    - 缓存超时时间
    - 缓存实例添加监控
    - 共享缓存key前缀区分
    - 任何缓存设置失效时间，不能集中一点
    - 低频不要放缓存中
    - 缓存数据不宜过大
    - HGETALL
    - 大量更新用批量模式
    - 分布式缓存由于本地缓存
    - 写缓存要写入完全正确数据
    - 读： 先缓存后书库
    - 写： 先数据后缓存
    - 本地缓存严格控制缓存对象个数及生命周期
    - 降级