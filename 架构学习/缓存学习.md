# 缓存学习
- 缓存算法
    - LRU(Least-Recently-Used)
    - LFU(Least-Frequently-Used)
    - LRU2(Least Recently Used 2)
    - 2Q(Two Queues)
    - SIZE
    - LRU-Threshold
    - Log(Size)+LRU
    - Hyper-G
    - Pitkow/Recker
    - Lowest-Latency-First
    - Hybrid Hybrid
    - LRV(Lowest Relative Value)
    - ARC(Adaptive Replacement Cache)
    - MRU(Most Recently Used)
    - FIFO(First in First out)
    - Random Cache
- Cache API
    - CachingProvider
    - CacheManager
    - Cache
    - Entry
- annotatin
    - @Cacheable
    - @CachePut
    - @CachEvict
    - @CacheConfig
- Ehcache
- guava
- memcached
- aerospike
- 缓存使用方式
    - Cache-Aside
    - Cache-As-SoR
    - Read-Through
    - Refresh-Ahead
    - Write-Through
    - Write-Behind
- 缓存协议
    - 文本西医
    - 二进制
- 缓存分类
    - 按位置
        - 客户端缓存
            - 页面缓存
            - 浏览器缓存
            - APP缓存
        - 服务端缓存
            - 数据库缓存
            - 平台级缓存
            - 应用级缓存
        - 网络中缓存
            - Web缓存代理
            - 边缘缓存
    - 规模
        - 单体缓存
        - 缓存集群
        - 分布式缓存
- 模式
    - 双读写
        - 读: 先读缓存再数据库再回写缓存
        - 写: 先写数据库再写缓存
    - 异步更新
        - 只读写缓存
    - 串联
        - 缓存读写
- 缓存分片
    - 客户端分片
    - 代理分片
    - 集群分片
- 迁移方案
    - 平滑迁移
        - 双写
        - 迁移历史数据
        - 切读
        - 下双写
    - 停机迁移
        - 停机应用
        - 迁移历史数据
        - 更改应用的数据源配置
        - 重新启动应用
    - 一致性哈希
- 问题
    - 缓存穿透
    - 缓存并发
        - 分布式锁
        - 本地锁
        - 软过期
    - 缓存雪崩
- 优秀实践
    - 内存大小预先评估
    - 缓存业务分离, 互不影响
    - 缓存实例数量
    - 缓存超时时间
    - 缓存实例添加监控
    - 共享缓存key前缀区分
    - 任何缓存设置失效时间，不能集中一点
    - 低频不要放缓存中
    - 缓存数据不宜过大
    - HGETALL
    - 大量更新用批量模式
    - 分布式缓存由于本地缓存
    - 写缓存要写入完全正确数据
    - 读： 先缓存后书库
    - 写： 先数据后缓存
    - 本地缓存严格控制缓存对象个数及生命周期
    - 降级