apiVersion: v1
kind: Service
metadata:
  name: mysql-service
spec:
  type: ClusterIP
  selector:
    app: mysql-pod
  ports:
    - name: mysql
      port: 3306
      targetPort: 3306
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-deployment
spec:
  selector:
    matchLabels:
      app: mysql-pod
  template:
    metadata:
      labels:
        app: mysql-pod
    spec:
      containers:
        - name: mysql-container
          image: mysql:8.0
          ports:
            - protocol: TCP
              containerPort: 3306
          env:
            - name:  MYSQL_ROOT_PASSWORD
              value: abc
            - name: MYSQL_DATABASE
              value: test
            - name: MYSQL_USER
              value: test
            - name: MYSQL_PASSWORD
              value: test
          volumeMounts:
            - name: mysql-conf
              mountPath: /var/lib/mysql-files/my.cnf
      volumes:
        - name: mysql-conf
          configMap:
            name: mysql-config-map
            items:
              - key: my.cnf
                path: my.cnf
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config-map
data:
  my.cnf: |
    [mysqld]
    #
    # 文件配置
    #
    # 根目录(安装目录)
    # basedir=/data/apps/mysql
    # 数据库文件
    # datadir=/var/lib/mysqld
    # 临时文件目录
    # tmpdir=/tmp
    # 进程ID的文件
    # pid-file=/var/run/mysqld/mysqld.pid
    # unix socket文件
    # socket=/var/run/mysqld/mysqld.sock
    # 所有线程所打开表的数量 [mysqld_safe] 中 “open-files-limit” 变量设置打开文件数量允许至少等于 table_cache 的值
    # table_open_cache=4096
    # 允许外部文件级别的锁. 打开文件锁会对性能造成负面影响
    # external-locking

    #
    # 监听配置
    #
    # 禁止使用DNS登入
    skip-name-resolve
    # 禁止使用TCP/IP登入,使用 Unix Sockets / 命令管道
    # skip-networking
    # 侦听的端口
    # port=3306
    # 操作系统在监听队列中所能保持的连接数
    # back_log=50
    # 服务所允许的同时会话数的上限
    # max_connections=3000
    # 连接最大的错误允许数量
    # max_connect_errors=50
    # 服务所能处理的请求包的最大大小以及服务所能处理的最大的请求大小
    # max_allowed_packet=32M

    #
    # 内存设置
    #
    # 独立的内存表所允许的最大容量
    # max_heap_table_size=128M
    # 随机读取数据缓冲区使用内存
    # read_rnd_buffer_size=16M
    # 排序缓冲区使用内存
    # sort_buffer_size=16M
    # 全联合缓冲区使用内存
    # join_buffer_size=16M

    #
    # 缓存
    # 开启查询缓存: ON / DEMAND / OFF
    # query_cache_type=off
    # 查询缓冲区使用内存
    # query_cache_size=128M
    # 只有小于此设定值的结果才会被缓冲
    # query_cache_limit=4M
    # 缓存可重用的线程数
    # thread_cache=16
    # thread_cache_size=16

    #
    # 事务
    #
    # 默认的事务隔离级别
    #    READ-UNCOMMITTED
    #    READ-COMMITTED
    #    REPEATABLE-READ
    #    SERIALIZABLE
    # transaction_isolation=REPEATABLE-READ

    #
    # 日志
    #
    # 日志配置
    # log=/usr/local/mysql/log/mysql-sql.log
    # log-error=/var/log/mysqld.log
    # 将警告打印输出到错误log文件
    # log_warnings
    # 记录慢速查询
    # log_slow_queries
    # 慢速查询日志配置
    # slow_query_log=1
    # long_query_time=6
    # slow_query_log_file=/var/lib/mysql/log/slow.log
    # 在慢速日志中记录更多的信息。
    # log_long_format

    #
    # 其他服务器设置
    #
    # 设置服务器端默认字符集
    default-character-set=utf8mb4
    character-set-server=utf8mb4
    # 当创建新表时作为默认使用的表类型
    # default_table_type=InnoDB
    # 线程使用的堆大小
    # thread_stack=512K
    # 内存中临时表的最大大小
    # tmp_table_size=128M
    # 避免MySQL的外部锁定，减少出错几率增强稳定性。
    # skip-locking
    # 被全文检索索引的最小的字长
    # ft_min_word_len=8
    # 线程：CPU个数的2倍
    # thread_concurrency=8
    # 这好似一个非0值，所有表在设置时间后释放，同步不刷新到硬盘上。在低资源的系统上使用。
    # flush_time=0
    # Disabling symbolic-links is recommended to prevent assorted security risks
    # symbolic-links=0
    # 默认关闭 Federated
    # skip-federated

    # 
    # 主从复制相关的设置
    # 
    # Master:
    # 唯一的服务辨识号,数值位于 1 到 2^32-1之间。
    # server-id=1
    # 打开二进制日志功能。
    # log-bin=mysql-bin
    # 指定对db_nameA记录二进制日志
    # binlog-do-db=db_nameA
    # 指定不对db_namB记录二进制日志
    # binlog-ignore-db=db_namB
    # binlog_cache_size=4M
    # 存活30天
    # expire_logs_days=30
    # default-storage-engine=InnoDB #默认启动InnoDB服务器
    # 复制结构中的master
    # master-host=
    # Slave:
    #  1) 使用 CHANGE MASTER TO :
    #   CHANGE MASTER TO MASTER_HOST=, MASTER_PORT=,
    #   MASTER_USER=, MASTER_PASSWORD= ; 
    #  2) 设置以下的变量.
    # 唯一的服务辨识号,位于1和2^32 – 1之间(并且和master不同)
    # server-id=2 
    # master上slave认证的用户名
    # master-user=
    # master上slave认证的密码
    # master-password=
    # master监听的端口
    # master-port=
    # log-bin=mysql-bi
    # 需要记录日志的数据库，相当于需要同步的数据库
    # binlog-do-db =repository1	
    # 使得slave只读
    # read_only
    # 若涉及及同步函数或者存储过程需要配置，否则主备会产生异常不能同步
    # log_bin_trust_function_creators=TRUE
    # 如果你在使用链式从服务器结构的复制模式 (A->B->C)
    # log_slave_updates

    #
    # sql_mode
    #       ALLOW_INVALID_DATES
    #       ANSI_QUOTES
    #       IGNORE_SPACE
    #       NO_AUTO_VALUE_ON_ZERO
    #       NO_ENGINE_SUBSITUTION
    #       NO_ZERO_DATE
    #       ONLY_FULL_GROUP_BY
    #       STRICT_ALL_TABLES
    #       STRICT_TRANS_TABLES
    # sql_mode=ONLY_FULL_GROUP_BY, STRICT_TRANS_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_ENGINE_SUBSTITUTION

    #
    # MyISAM 相关选项
    #
    # 关键词缓冲的大小
    # key_buffer_size=128M
    # 用来做MyISAM表全表扫描的缓冲大小
    # read_buffer_size=8M
    # MyISAM使用特殊的类似树的cache来使得突发插入
    # bulk_insert_buffer_size=256M
    # 此缓冲当MySQL需要在 REPAIR, OPTIMIZE, ALTER 以及 LOAD DATA INFILE 到一个空表中引起重建索引时被分配.
    # 这在每个线程中被分配.所以在设置大值时需要小心.
    # myisam_sort_buffer_size=256M
    # MySQL 重建索引时所允许的最大临时文件的大小 (当 REPAIR, ALTER TABLE 或者 LOAD DATA INFILE).
    # 如果文件大小比此值更大,索引会通过键值缓冲创建(更慢)
    # myisam_max_sort_file_size=10G
    # 如果被用来更快的索引创建索引所使用临时文件大于制定的值,那就使用键值缓冲方法.
    # 这主要用来强制在大表中长字串键去使用慢速的键值缓冲方法来创建索引.
    # myisam_max_extra_sort_file_size=10G
    # 如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们.
    # 这对于拥有多个 CPU 以及大量内存情况的用户,是一个很好的选择.
    # myisam_repair_threads=1
    # 自动检查和修复没有适当关闭的 MyISAM 表.
    # myisam_recover

    #
    #  BDB相关选项
    # 
    # skip-bdb

    # 
    # INNODB相关选项
    # 
    # skip-innodb
    # InnoDB使用的缓冲池来保存索引和原始数据
    # innodb_buffer_pool_size=6G
    # InnoDB表空间路径
    # innodb_data_file_path=ibdata1:10M:autoextend
    # InnoDB表空间文件目录
    # innodb_data_home_dir=
    # 用来同步IO操作的IO线程的数量
    # innodb_file_io_threads=8
    # 如果你发现 InnoDB 表空间损坏, 设置此值为一个非零值可能帮助你导出你的表.
    # innodb_force_recovery=1
    # InnoDb核心内的允许线程数量
    # innodb_thread_concurrency=16
    # 0 : 日志只大约每秒写入日志文件并且日志文件刷新到磁盘
    # 1 : InnoDB 会在每次提交后刷新(fsync)事务日志到磁盘上
    # 2 : 日志写入日志文件在每次提交后,但是日志文件只有大约每秒才会刷新到磁盘上
    # innodb_flush_log_at_trx_commit=2
    # 加速 InnoDB 的关闭. 这会阻止InnoDB在关闭时做全清除以及插入缓冲合并
    # innodb_fast_shutdown
    # 用来缓冲日志数据的缓冲区的大小
    # innodb_log_buffer_size=16M
    # 在日志组中每个日志文件的大小
    # innodb_log_file_size=512M
    # 在日志组中的文件总数
    # innodb_log_files_in_group=3
    # InnoDB的日志文件所在位置
    # innodb_log_group_home_dir
    # 在 InnoDB 缓冲池中最大允许的脏页面的比例
    # innodb_max_dirty_pages_pct=90
    # InnoDB 用来刷新日志的方法
    # 默认值是 “fdatasync”, 另一个是 “O_DSYNC”.
    # 一般来说，如果你有硬件 RAID 控制器，并且其独立缓存采用 write-back 机制，并有着电池断电保护，那么应该设置配置为 O_DIRECT
    # 否则，大多数情况下应将其设为 fdatasync
    # innodb_flush_method=fdatasync
    # 在被回滚前,一个 InnoDB 的事务应该等待一个锁被批准多久
    # innodb_lock_wait_timeout=120
    # InnoDB是否需要将所有表的数据和索引存放在共享表空间里
    # innodb_file_per_table=on
    # 额外元数据内存池。在开启时从系统中(内核中)申请更加大的内存，而现代的OS足够你使用，你不需要修改这个值。
    # innodb_additional_mem_pool_size=2M
    # 当Innodb系统的表空间文件满了后，它将自动额外增加这么大空间
    # innodb_autoextend_increment=64
    # Innodb缓存池的分区数。在多字节的系统中使用缓存池，可以将缓冲池分成多个实例，以减少不同线程的读写。
    # innodb_buffer_pool_instances=8
    # Innodb中的并发线程数
    # innodb_concurrency_tickets=5000
    # 旧子表的插入锁定时间，然后移动到新表中
    # innodb_old_blocks_time=1000
    # 定义最小打开的.ibd文件数在同一时间，最小为10.
    # innodb_open_files=300
    # 当启用时，InnoDB更新元数据报表统计。
    # innodb_stats_on_metadata=0
    # Use the following list of values: 0 for crc32, 1 for strict_crc32, 2 for innodb, 3 for strict_innodb, 4 for none, 5 for strict_none.
    # innodb_checksum_algorithm=0

    [mysqld_safe]
    # 增加每个进程的可打开文件数量
    # open-files-limit=8192